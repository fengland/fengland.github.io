msgid ""
msgstr ""
"Project-Id-Version: Linera\n"
"POT-Creation-Date: 2024-03-08T20:52:43+08:00\n"
"PO-Revision-Date: 2024-03-09 11:33+0800\n"
"Last-Translator:  <feng_land@163.com>\n"
"Language-Team: Language zh-CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/SUMMARY.md:3 src/introduction.md:1
msgid "The Linera Developer Manual"
msgstr ""

#: src/SUMMARY.md:5 src/getting_started.md:1
msgid "Getting Started"
msgstr ""

#: src/SUMMARY.md:6
msgid "Installation"
msgstr ""

#: src/SUMMARY.md:7
msgid "Hello, Linera"
msgstr ""

#: src/SUMMARY.md:11 src/core_concepts.md:1
msgid "The Linera Protocol"
msgstr ""

#: src/SUMMARY.md:12 src/core_concepts/overview.md:1
msgid "Overview"
msgstr ""

#: src/SUMMARY.md:13
msgid "Microchains"
msgstr ""

#: src/SUMMARY.md:14
msgid "Wallets"
msgstr ""

#: src/SUMMARY.md:15
msgid "Node Service"
msgstr ""

#: src/SUMMARY.md:16
msgid "Applications"
msgstr ""

#: src/SUMMARY.md:20 src/sdk.md:1
msgid "Writing Linera Applications"
msgstr ""

#: src/SUMMARY.md:21
msgid "Creating a Project"
msgstr ""

#: src/SUMMARY.md:22
msgid "Creating the Application State"
msgstr ""

#: src/SUMMARY.md:23
msgid "Defining the ABI"
msgstr ""

#: src/SUMMARY.md:24
msgid "Writing the Contract Binary"
msgstr ""

#: src/SUMMARY.md:25
msgid "Writing the Service Binary"
msgstr ""

#: src/SUMMARY.md:26
msgid "Deploying the Application"
msgstr ""

#: src/SUMMARY.md:27
msgid "Cross-Chain Messages"
msgstr ""

#: src/SUMMARY.md:28
msgid "Calling other Applications"
msgstr ""

#: src/SUMMARY.md:29
msgid "Printing Logs from an Application"
msgstr ""

#: src/SUMMARY.md:30
msgid "Writing Tests"
msgstr ""

#: src/SUMMARY.md:34 src/advanced_topics.md:1
msgid "Advanced Topics"
msgstr ""

#: src/SUMMARY.md:35
msgid "Views"
msgstr ""

#: src/SUMMARY.md:36
msgid "Persistent Storage"
msgstr ""

#: src/SUMMARY.md:37
msgid "Validators"
msgstr ""

#: src/SUMMARY.md:38
msgid "Creating New Blocks"
msgstr ""

#: src/SUMMARY.md:42
msgid "Appendix"
msgstr ""

#: src/SUMMARY.md:43
msgid "Glossary"
msgstr ""

#: src/SUMMARY.md:44 src/videos.md:1
msgid "Videos"
msgstr ""

#: src/introduction.md:5
msgid "![The Linera banner](introduction.assets/Linera-Header_1920x284px.svg)"
msgstr ""

#: src/introduction.md:7
msgid ""
"[The Linera Developer Manual](https://linera.dev/introduction.html#the-"
"linera-developer-manual)"
msgstr ""

#: src/introduction.md:9
msgid ""
"Welcome to the developer manual of Linera, a decentralized protocol designed "
"for **highly scalable, low-latency Web3 applications**."
msgstr ""

#: src/introduction.md:11
msgid ""
"This documentation is intended for developers who wish to learn more about "
"Linera and its programming model by prototyping applications on top of the "
"Linera Rust SDK."
msgstr ""

#: src/introduction.md:13
msgid "**NEW: Publish and test your Web3 application on the Linera Devnet!**"
msgstr ""

#: src/introduction.md:15
msgid ""
"Install [the Linera CLI tool](https://linera.dev/getting_started/"
"installation.html#installing-from-cratesio) then follow the instructions on "
"[this page](https://linera.dev/getting_started/hello_linera.html#using-the-"
"devnet) to claim a microchain and publish your first application on the "
"current Devnet."
msgstr ""

#: src/introduction.md:17
msgid ""
"To join our community and get involved in the development of the Linera "
"ecosystem, check out our [GitHub repository](https://github.com/linera-io/"
"linera-protocol), our [website](https://linera.io/), and find us on social "
"media channels such as [youtube](https://www.youtube.com/@linera_io), "
"[twitter](https://twitter.com/linera_io), [telegram](https://t.me/"
"linera_official), and [discord](https://discord.gg/linera)."
msgstr ""

#: src/introduction.md:19
msgid "Let's get started!"
msgstr ""

#: src/getting_started.md:3
msgid ""
"In this section, we will cover the necessary steps to install the Linera "
"toolchain and give a short example to get started with the Linera SDK."
msgstr ""

#: src/getting_started/installation.md:1
msgid "1.1. Installation"
msgstr ""

#: src/getting_started/installation.md:3
msgid "Let's start with the installation of the Linera development tools."
msgstr ""

#: src/getting_started/installation.md:5
msgid ""
"[Overview](https://linera.dev/getting_started/installation.html#overview)"
msgstr ""

#: src/getting_started/installation.md:7
msgid "The Linera toolchain consist of two crates:"
msgstr ""

#: src/getting_started/installation.md:9
msgid ""
"`linera-sdk` is the main library to program Linera applications in Rust. It "
"also includes the Wasm test runner binary `linera-wasm-test-runner`."
msgstr ""

#: src/getting_started/installation.md:10
msgid "`linera-service` defines a number of binaries, including:"
msgstr ""

#: src/getting_started/installation.md:11
msgid "`linera` -- the main client tool, used to operate development wallets,"
msgstr ""

#: src/getting_started/installation.md:12
msgid ""
"`linera-proxy` -- the proxy service, acting as a public entrypoint for each "
"validator,"
msgstr ""

#: src/getting_started/installation.md:13
msgid ""
"`linera-server` -- the service run by each worker of a validator, hidden "
"behind the proxy."
msgstr ""

#: src/getting_started/installation.md:15
msgid ""
"[Requirements](https://linera.dev/getting_started/installation."
"html#requirements)"
msgstr ""

#: src/getting_started/installation.md:17
msgid ""
"The operating systems currently supported by the Linera toolchain can be "
"summarized as follows:"
msgstr ""

#: src/getting_started/installation.md:19
msgid "Linux x86 64-bit"
msgstr ""

#: src/getting_started/installation.md:19
msgid "Mac OS (M1 / M2)"
msgstr ""

#: src/getting_started/installation.md:19
msgid "Mac OS (x86)"
msgstr ""

#: src/getting_started/installation.md:19
msgid "Windows"
msgstr ""

#: src/getting_started/installation.md:21
msgid "✓ Main platform"
msgstr ""

#: src/getting_started/installation.md:21
msgid "✓ Working"
msgstr ""

#: src/getting_started/installation.md:21
msgid "Untested"
msgstr ""

#: src/getting_started/installation.md:23
msgid ""
"The main prerequisites to install the Linera toolchain are Rust, Wasm, and "
"Protoc. They can be installed as follows on Linux:"
msgstr ""

#: src/getting_started/installation.md:25
msgid "Rust and Wasm"
msgstr ""

#: src/getting_started/installation.md:26
msgid "`curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`"
msgstr ""

#: src/getting_started/installation.md:27
msgid "`rustup target add wasm32-unknown-unknown`"
msgstr ""

#: src/getting_started/installation.md:28
msgid "Protoc"
msgstr ""

#: src/getting_started/installation.md:29
msgid ""
"`curl -LO https://github.com/protocolbuffers/protobuf/releases/download/"
"v21.11/protoc-21.11-linux-x86_64.zip`"
msgstr ""

#: src/getting_started/installation.md:30
msgid "`unzip protoc-21.11-linux-x86_64.zip -d $HOME/.local`"
msgstr ""

#: src/getting_started/installation.md:31
msgid ""
"If `~/.local` is not in your path, add it: `export PATH=\"$PATH:$HOME/.local/"
"bin\"`"
msgstr ""

#: src/getting_started/installation.md:32
msgid ""
"On certain Linux distributions, you may have to install development packages "
"such as `g++`, `libclang-dev` and `libssl-dev`."
msgstr ""

#: src/getting_started/installation.md:34
msgid ""
"For MacOS support and for additional requirements needed to test the Linera "
"protocol itself, see the installation section on [GitHub](https://github.com/"
"linera-io/linera-protocol/blob/main/INSTALL.md)."
msgstr ""

#: src/getting_started/installation.md:36
msgid "This manual was tested with the following Rust toolchain:"
msgstr ""

#: src/getting_started/installation.md:38
msgid ""
"```text\n"
"[toolchain]\n"
"channel = \"1.75.0\"\n"
"components = [ \"clippy\", \"rustfmt\", \"rust-src\" ]\n"
"targets = [ \"wasm32-unknown-unknown\" ]\n"
"profile = \"minimal\"\n"
"```"
msgstr ""

#: src/getting_started/installation.md:46
msgid ""
"[Installing from crates.io](https://linera.dev/getting_started/installation."
"html#installing-from-cratesio)"
msgstr ""

#: src/getting_started/installation.md:48
msgid "You may install the Linera binaries with"
msgstr ""

#: src/getting_started/installation.md:55
msgid "and use `linera-sdk` as a library for Linera Wasm applications:"
msgstr ""

#: src/getting_started/installation.md:61
msgid ""
"The version number `0.9.0` corresponds to the current Devnet of Linera and "
"may change frequently."
msgstr ""

#: src/getting_started/installation.md:63
msgid ""
"[Installing from GitHub](https://linera.dev/getting_started/installation."
"html#installing-from-github)"
msgstr ""

#: src/getting_started/installation.md:65
msgid ""
"Download the source from [GitHub](https://github.com/linera-io/linera-"
"protocol):"
msgstr ""

#: src/getting_started/installation.md:69
msgid "# Current release branch\n"
msgstr ""

#: src/getting_started/installation.md:72
msgid "To install the Linera toolchain locally from source, you may run:"
msgstr ""

#: src/getting_started/installation.md:79
msgid ""
"Alternatively, for developing and debugging, you may instead use the "
"binaries compiled in debug mode, e.g. using `export PATH=\"$PWD/target/debug:"
"$PATH\"`."
msgstr ""

#: src/getting_started/installation.md:81
msgid ""
"This manual was tested against the following commit of the [repository]"
"(https://github.com/linera-io/linera-protocol):"
msgstr ""

#: src/getting_started/installation.md:87
msgid ""
"[Bash helper (optional)](https://linera.dev/getting_started/installation."
"html#bash-helper-optional)"
msgstr ""

#: src/getting_started/installation.md:89
msgid ""
"Consider adding the output of `linera net helper` to your `~/.bash_profile` "
"to help with [automation](https://linera.dev/core_concepts/wallets."
"html#automation-in-bash)."
msgstr ""

#: src/getting_started/installation.md:91
msgid ""
"[Getting help](https://linera.dev/getting_started/installation.html#getting-"
"help)"
msgstr ""

#: src/getting_started/installation.md:93
msgid ""
"If installation fails, reach out to the team (e.g. on [Discord](https://"
"discord.gg/linera)) to help troubleshoot your issue or [create an issue]"
"(https://github.com/linera-io/linera-protocol/issues/new) on GitHub."
msgstr ""

#: src/getting_started/hello_linera.md:1
msgid "1.2. Hello, Linera"
msgstr ""

#: src/getting_started/hello_linera.md:3
msgid ""
"[Hello, Linera](https://linera.dev/getting_started/hello_linera.html#hello-"
"linera)"
msgstr ""

#: src/getting_started/hello_linera.md:5
msgid ""
"This section is about interacting with the Devnet, running a local "
"development network, then compiling and deploying your first application "
"from scratch."
msgstr ""

#: src/getting_started/hello_linera.md:7
msgid ""
"By the end of this section, you'll have a [microchain](https://linera.dev/"
"core_concepts/microchains.html) on the Devnet and/or on your local network, "
"and a working application that can be queried using GraphQL."
msgstr ""

#: src/getting_started/hello_linera.md:9
msgid ""
"[Using the Devnet](https://linera.dev/getting_started/hello_linera."
"html#using-the-devnet)"
msgstr ""

#: src/getting_started/hello_linera.md:11
msgid ""
"The Linera Devnet is a deployment of the Linera protocol that's useful for "
"developers. It should not be considered stable, and can be restarted from a "
"clean slate and new genesis at any time."
msgstr ""

#: src/getting_started/hello_linera.md:13
msgid ""
"To interact with the Devnet, some tokens are needed. A Faucet service is "
"available to create new microchains and obtain some test tokens. To do so, "
"this must be configured when initializing the wallet:"
msgstr ""

#: src/getting_started/hello_linera.md:19
msgid ""
"This creates a new microchain on Devnet with some initial test tokens, and "
"the chain is automatically added to the newly instantiated wallet."
msgstr ""

#: src/getting_started/hello_linera.md:21
msgid ""
"Make sure to use a Linera toolchain [compatible with the current Devnet]"
"(https://linera.dev/getting_started/installation.html#installing-from-"
"cratesio)."
msgstr ""

#: src/getting_started/hello_linera.md:23
msgid ""
"[Starting a Local Test Network](https://linera.dev/getting_started/"
"hello_linera.html#starting-a-local-test-network)"
msgstr ""

#: src/getting_started/hello_linera.md:25
msgid ""
"Another option is to start your own local development network. A development "
"network consists of a number of [validators](https://linera.dev/"
"advanced_topics/validators.html), each of which consist of an ingress proxy "
"(aka. a \"load balancer\") and a number of workers (aka. \"physical shards"
"\")."
msgstr ""

#: src/getting_started/hello_linera.md:27
msgid "To start a local network, run the following command:"
msgstr ""

#: src/getting_started/hello_linera.md:33
msgid ""
"This will start a validator with the default number of shards and create a "
"temporary directory storing the entire network state."
msgstr ""

#: src/getting_started/hello_linera.md:35
msgid ""
"This will set up a number of initial chains and create an initial wallet to "
"operate them."
msgstr ""

#: src/getting_started/hello_linera.md:37
msgid ""
"[Using the Initial Test Wallet](https://linera.dev/getting_started/"
"hello_linera.html#using-the-initial-test-wallet)"
msgstr ""

#: src/getting_started/hello_linera.md:39
msgid ""
"`linera net up` prints Bash statements on its standard output to help you "
"configure your terminal to use the initial wallet of the new test network, "
"for instance:"
msgstr ""

#: src/getting_started/hello_linera.md:42
msgid ""
"\"/var/folders/3d/406tbklx3zx2p3_hzzpfqdbc0000gn/T/.tmpvJ6lJI/wallet.json\""
msgstr ""

#: src/getting_started/hello_linera.md:43
msgid ""
"\"rocksdb:/var/folders/3d/406tbklx3zx2p3_hzzpfqdbc0000gn/T/.tmpvJ6lJI/linera."
"db\""
msgstr ""

#: src/getting_started/hello_linera.md:46
msgid ""
"This wallet is only valid for the lifetime of a single network. Every time a "
"local network is restarted, the wallet needs to be reconfigured."
msgstr ""

#: src/getting_started/hello_linera.md:48
msgid ""
"[Interacting with the Network](https://linera.dev/getting_started/"
"hello_linera.html#interacting-with-the-network)"
msgstr ""

#: src/getting_started/hello_linera.md:50
msgid ""
"In the following examples, we assume that either the wallet was initialized "
"to interact with the Devnet or the variables `LINERA_WALLET` and "
"`LINERA_STORAGE` are both set and point to the initial wallet of the running "
"local network."
msgstr ""

#: src/getting_started/hello_linera.md:52
msgid ""
"The main way of interacting with the network and deploying applications is "
"using the `linera` client."
msgstr ""

#: src/getting_started/hello_linera.md:54
msgid ""
"To check that the network is working, you can synchronize your [default "
"chain](https://linera.dev/core_concepts/wallets.html) with the rest of the "
"network and display the chain balance as follows:"
msgstr ""

#: src/getting_started/hello_linera.md:61
msgid "You should see an output number, e.g. `10`."
msgstr ""

#: src/getting_started/hello_linera.md:63
msgid ""
"[Building an Example Application](https://linera.dev/getting_started/"
"hello_linera.html#building-an-example-application)"
msgstr ""

#: src/getting_started/hello_linera.md:65
msgid ""
"Applications running on Linera are [Wasm](https://webassembly.org/) "
"bytecode. Each validator and client has a built-in Wasm virtual machine (VM) "
"which can execute bytecode."
msgstr ""

#: src/getting_started/hello_linera.md:67
msgid ""
"Let's build the `counter` application from the `examples/` subdirectory:"
msgstr ""

#: src/getting_started/hello_linera.md:73
msgid ""
"Note: This will automatically build Wasm, not native code, thanks to the "
"configuration file `examples/.cargo/config.toml`."
msgstr ""

#: src/getting_started/hello_linera.md:75
msgid ""
"[Publishing your Application](https://linera.dev/getting_started/"
"hello_linera.html#publishing-your-application)"
msgstr ""

#: src/getting_started/hello_linera.md:77
msgid ""
"You can publish the bytecode and create an application using it on your "
"local network using the `linera` client's `publish-and-create` command and "
"provide:"
msgstr ""

#: src/getting_started/hello_linera.md:79 src/sdk/deploy.md:11
#: src/sdk/deploy.md:31
msgid "The location of the contract bytecode"
msgstr ""

#: src/getting_started/hello_linera.md:80 src/sdk/deploy.md:12
#: src/sdk/deploy.md:32
msgid "The location of the service bytecode"
msgstr ""

#: src/getting_started/hello_linera.md:81 src/sdk/deploy.md:13
#: src/sdk/deploy.md:33
msgid "The JSON encoded initialization arguments"
msgstr ""

#: src/getting_started/hello_linera.md:86 src/sdk/deploy.md:18
#: src/sdk/deploy.md:38
msgid "\"42\""
msgstr ""

#: src/getting_started/hello_linera.md:89
msgid "Congratulations! You've published your first application on Linera!"
msgstr ""

#: src/getting_started/hello_linera.md:91
msgid ""
"[Querying your Application](https://linera.dev/getting_started/hello_linera."
"html#querying-your-application)"
msgstr ""

#: src/getting_started/hello_linera.md:93
msgid ""
"Now let's query your application to get the current counter value. To do "
"that, we need to use the client running in [_service_ mode](https://linera."
"dev/core_concepts/node_service.html). This will expose a bunch of APIs "
"locally which we can use to interact with applications on the network."
msgstr ""

#: src/getting_started/hello_linera.md:99
msgid ""
"Navigate to `http://localhost:8080` in your browser to access the GraphiQL, "
"the [GraphQL](https://graphql.org/) IDE. We'll look at this in more detail "
"in a [later section](https://linera.dev/core_concepts/node_service."
"html#graphiql-ide); for now, list the applications deployed on your default "
"chain e476… by running:"
msgstr ""

#: src/getting_started/hello_linera.md:101
msgid ""
"```gql\n"
"query {\n"
"  applications(\n"
"    chainId: "
"\"e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65\"\n"
"  ) {\n"
"    id\n"
"    description\n"
"    link\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/getting_started/hello_linera.md:113
msgid ""
"Since we've only deployed one application, the results returned have a "
"single entry."
msgstr ""

#: src/getting_started/hello_linera.md:115
msgid ""
"At the bottom of the returned JSON there is a field `link`. To interact with "
"your application copy and paste the link into a new browser tab."
msgstr ""

#: src/getting_started/hello_linera.md:117
msgid "Finally, to query the counter value, run:"
msgstr ""

#: src/getting_started/hello_linera.md:125
msgid ""
"This will return a value of `42`, which is the initialization argument we "
"specified when deploying our application."
msgstr ""

#: src/core_concepts.md:3
msgid ""
"We now describe the main concepts of the Linera protocol in more details."
msgstr ""

#: src/core_concepts/overview.md:3
msgid ""
"Linera is a decentralized infrastructure optimized for Web3 applications "
"that require guaranteed performance for an unlimited number of active users."
msgstr ""

#: src/core_concepts/overview.md:5
msgid ""
"The core idea of the Linera protocol is to run many lightweight blockchains, "
"called **microchains**, in parallel in a single set of validators."
msgstr ""

#: src/core_concepts/overview.md:7
msgid ""
"[How does it work?](https://linera.dev/core_concepts/overview.html#how-does-"
"it-work)"
msgstr ""

#: src/core_concepts/overview.md:9
msgid ""
"In Linera, user wallets operate their own microchains. The owner of a chain "
"chooses when to add new blocks to the chain and what goes inside the blocks. "
"Such chains with a single user are called **user chains**."
msgstr ""

#: src/core_concepts/overview.md:11
msgid ""
"Users may add new blocks to their chains in order to process **incoming "
"messages** from other chains or to execute secure **operations** on their "
"accounts, for instance to transfer assets to another user."
msgstr ""

#: src/core_concepts/overview.md:13
msgid ""
"Importantly, validators ensure that all new blocks are **valid**. For "
"instance, transfer operations must originate from accounts with sufficient "
"funds; and incoming messages must have been actually sent from another "
"chain. Blocks are verified by validators in the same way for every chain."
msgstr ""

#: src/core_concepts/overview.md:15
msgid ""
"A Linera **application** is a Wasm program that defines its own state and "
"operations. Users can publish bytecode and initialize an application on one "
"chain, and it will be automatically deployed to all chains where it is "
"needed, with a separate state on each chain."
msgstr ""

#: src/core_concepts/overview.md:17
msgid ""
"To ensure coordination across chains, an application may rely on "
"asynchronous **cross-chain messages**. Message payloads are application-"
"specific and opaque to the rest of the system."
msgstr ""

#: src/core_concepts/overview.md:37
msgid ""
"The number of applications present on a single chain is not limited. On the "
"same chain, applications are **composed** as usual using synchronous calls."
msgstr ""

#: src/core_concepts/overview.md:39
msgid ""
"The current Linera SDK uses **Rust** as a source language to create Wasm "
"applications. It relies on the normal Rust toolchains so that Rust "
"programmers can work in their preferred environments."
msgstr ""

#: src/core_concepts/overview.md:41
msgid ""
"[How does Linera compare to existing multi-chain infrastructure?](https://"
"linera.dev/core_concepts/overview.html#how-does-linera-compare-to-existing-"
"multi-chain-infrastructure)"
msgstr ""

#: src/core_concepts/overview.md:43
msgid ""
"Linera is the first infrastructure designed to support many chains in "
"parallel, and notably an arbitrary number of **user chains** meant to be "
"operated by user wallets."
msgstr ""

#: src/core_concepts/overview.md:45
msgid ""
"In traditional multi-chain infrastructures, each chain usually runs a full "
"blockchain protocol in a separate set of validators. Creating a new chain or "
"exchanging messages between chains is expensive. As a result, the total "
"number of chains is generally limited. Some chains may be specialized to a "
"given use case: these are called \"app chains\"."
msgstr ""

#: src/core_concepts/overview.md:47
msgid "In contrast, Linera is optimized for a large number of user chains:"
msgstr ""

#: src/core_concepts/overview.md:49
msgid "Users only create blocks in their chain when needed;"
msgstr ""

#: src/core_concepts/overview.md:50
msgid "Creating a microchain does not require onboarding validators;"
msgstr ""

#: src/core_concepts/overview.md:51
msgid "All chains have the same level of security;"
msgstr ""

#: src/core_concepts/overview.md:52
msgid ""
"Microchains communicate efficiently using the internal networks of "
"validators;"
msgstr ""

#: src/core_concepts/overview.md:53
msgid ""
"Validators are internally sharded (like a regular web service) and may "
"adjust their capacity elastically by adding or removing internal workers."
msgstr ""

#: src/core_concepts/overview.md:55
msgid ""
"Besides user chains, the [Linera protocol](https://linera.io/whitepaper) is "
"designed to support other types of microchains, called \"permissioned\" and "
"\"public\" chains. Public chains are operated by validators. In this regard, "
"they are similar to classical blockchains. Permissioned chains are meant to "
"be used for temporary interactions between users, such as atomic swaps."
msgstr ""

#: src/core_concepts/overview.md:57
msgid ""
"[Why build on top of Linera?](https://linera.dev/core_concepts/overview."
"html#why-build-on-top-of-linera)"
msgstr ""

#: src/core_concepts/overview.md:59
msgid ""
"We believe that many high-value use cases are currently out of reach of "
"existing Web3 infrastructures because of the challenges of serving **many "
"active users** simultaneously without degrading user experience "
"(unpredictable fees, latency, etc)."
msgstr ""

#: src/core_concepts/overview.md:61
msgid ""
"Examples of applications that require processing time-sensitive transactions "
"created by many simultaneous users include:"
msgstr ""

#: src/core_concepts/overview.md:63
msgid "real-time micro-payments and micro-rewards,"
msgstr ""

#: src/core_concepts/overview.md:64
msgid "social data feeds,"
msgstr ""

#: src/core_concepts/overview.md:65
msgid "real-time auction systems,"
msgstr ""

#: src/core_concepts/overview.md:66
msgid "turn-based games,"
msgstr ""

#: src/core_concepts/overview.md:67
msgid ""
"version control systems for software, data pipelines, or AI training "
"pipelines."
msgstr ""

#: src/core_concepts/overview.md:69
msgid ""
"Lightweight user chains are instrumental in providing elastic scalability "
"but they have other benefits as well. Because user chains have fewer blocks "
"than traditional blockchains, in Linera, the full-nodes of user chains will "
"be embedded into the users' wallets, typically deployed as a browser "
"extension."
msgstr ""

#: src/core_concepts/overview.md:71
msgid ""
"This means that Web UIs connected to a wallet will be able to query the "
"state of the user chain directly (no API provider, no light client) using "
"familiar frameworks (React/GraphQL). Furthermore, wallets will be able to "
"leverage the full node as well for security purposes, including to display "
"meaningful confirmation messages to users."
msgstr ""

#: src/core_concepts/overview.md:73
msgid ""
"[What is the current state of the development of Linera?](https://linera.dev/"
"core_concepts/overview.html#what-is-the-current-state-of-the-development-of-"
"linera)"
msgstr ""

#: src/core_concepts/overview.md:75
msgid ""
"The [reference open-source implementation](https://github.com/linera-io/"
"linera-protocol) of Linera is under active development. It already includes "
"a Web3 SDK with the necessary features to prototype simple Web3 applications "
"and test them locally on the same machine. Notably, Web UIs (possibly "
"reactive) can already be built on top of Wasm-embedded GraphQL services, and "
"tested locally in the browser."
msgstr ""

#: src/core_concepts/overview.md:77
msgid "The main limitations of our current Web3 SDK include:"
msgstr ""

#: src/core_concepts/overview.md:79
msgid ""
"Web UIs need to query a local HTTP service acting as a wallet. This setup is "
"meant to be temporary and for testing only: in the future, web UIs will "
"securely connect to a Wallet installed as a browser extension, as usual."
msgstr ""

#: src/core_concepts/overview.md:80
msgid ""
"Only user chains are currently available for testing and documented in this "
"manual. Support for other types of chain (called \"public\" and "
"\"permissioned\") will be added later."
msgstr ""

#: src/core_concepts/overview.md:82
msgid ""
"The main development workstreams of Linera, beyond its SDK, can be broken "
"down as follows."
msgstr ""

#: src/core_concepts/overview.md:84
msgid ""
"[Core Protocol](https://linera.dev/core_concepts/overview.html#core-protocol)"
msgstr ""

#: src/core_concepts/overview.md:86
msgid "User chains"
msgstr ""

#: src/core_concepts/overview.md:87
msgid "Permissioned chain (core protocol only)"
msgstr ""

#: src/core_concepts/overview.md:88
msgid "Cross-chain messages"
msgstr ""

#: src/core_concepts/overview.md:89
msgid "Cross-chain pub/sub channels (initial version)"
msgstr ""

#: src/core_concepts/overview.md:90
msgid "Bytecode publishing"
msgstr ""

#: src/core_concepts/overview.md:91
msgid "Application creation"
msgstr ""

#: src/core_concepts/overview.md:92
msgid "Reconfigurations of validators"
msgstr ""

#: src/core_concepts/overview.md:93
msgid "Initial support for gas fees"
msgstr ""

#: src/core_concepts/overview.md:94
msgid "Initial support for storage fees and storage limits"
msgstr ""

#: src/core_concepts/overview.md:95
msgid "External services to help users create their first chain"
msgstr ""

#: src/core_concepts/overview.md:96
msgid ""
"Permissioned chains (adding operation access control, demo of atomic swaps, "
"etc)"
msgstr ""

#: src/core_concepts/overview.md:97
msgid "Public chains (adding leader election, inbox constraints, etc)"
msgstr ""

#: src/core_concepts/overview.md:98
msgid ""
"Support for easy onboarding of user chains into a new application (removing "
"the need to accept requests)"
msgstr ""

#: src/core_concepts/overview.md:99
msgid "Improved pub/sub channels (removing the need to accept subscriptions)"
msgstr ""

#: src/core_concepts/overview.md:100
msgid "Blob storage for applications (generalizing bytecode storage)"
msgstr ""

#: src/core_concepts/overview.md:101
msgid "Support for archiving chains"
msgstr ""

#: src/core_concepts/overview.md:102
msgid ""
"Wallet-friendly chain clients (compile to Wasm/JS, do not maintain execution "
"states for other chains)"
msgstr ""

#: src/core_concepts/overview.md:103
msgid "General tokenomics and incentives for all stakeholders"
msgstr ""

#: src/core_concepts/overview.md:104
msgid "Governance on the admin chain (e.g. DPoS, onboarding of validators)"
msgstr ""

#: src/core_concepts/overview.md:105
msgid "Auditing procedures"
msgstr ""

#: src/core_concepts/overview.md:107
msgid ""
"[Wasm VM integration](https://linera.dev/core_concepts/overview.html#wasm-vm-"
"integration)"
msgstr ""

#: src/core_concepts/overview.md:109
msgid "Support for the Wasmer VM"
msgstr ""

#: src/core_concepts/overview.md:110
msgid "Support for the Wasmtime VM (experimental)"
msgstr ""

#: src/core_concepts/overview.md:111
msgid "Test gas metering and deterministic execution across VMs"
msgstr ""

#: src/core_concepts/overview.md:112
msgid "Composing Wasm applications on the same chain (initial version)"
msgstr ""

#: src/core_concepts/overview.md:113
msgid "Enhanced composability with \"sessions\""
msgstr ""

#: src/core_concepts/overview.md:114
msgid "Support for non-blocking (yet deterministic) calls to storage"
msgstr ""

#: src/core_concepts/overview.md:115
msgid "Support for read-only GraphQL services in Wasm"
msgstr ""

#: src/core_concepts/overview.md:116
msgid "Support for mocked system APIs (initial version)"
msgstr ""

#: src/core_concepts/overview.md:117
msgid "More efficient cross-application calls"
msgstr ""

#: src/core_concepts/overview.md:118
msgid ""
"Improve host/guest stub generation to make mocks easier (currently wit-"
"bindgen)"
msgstr ""

#: src/core_concepts/overview.md:119
msgid "Compile user full node to Wasm/JS"
msgstr ""

#: src/core_concepts/overview.md:121
msgid "[Storage](https://linera.dev/core_concepts/overview.html#storage)"
msgstr ""

#: src/core_concepts/overview.md:123
msgid ""
"Object management library (\"linera-views\") on top of Key-Value store "
"abstraction"
msgstr ""

#: src/core_concepts/overview.md:124
msgid "Support for Rocksdb"
msgstr ""

#: src/core_concepts/overview.md:125
msgid "Experimental support for DynamoDb"
msgstr ""

#: src/core_concepts/overview.md:126
msgid "Initial derive macros for GraphQL"
msgstr ""

#: src/core_concepts/overview.md:127
msgid "Initial support for ScyllaDb"
msgstr ""

#: src/core_concepts/overview.md:128
msgid "Make library fully extensible by users (requires better GraphQL macros)"
msgstr ""

#: src/core_concepts/overview.md:129
msgid ""
"Performance benchmarks and improvements (including faster state hashing)"
msgstr ""

#: src/core_concepts/overview.md:130
msgid "Production-grade support for the chosen main database"
msgstr ""

#: src/core_concepts/overview.md:131
msgid "Support global object locks (needed for dynamic sharding)"
msgstr ""

#: src/core_concepts/overview.md:132
msgid "Tooling for debugging"
msgstr ""

#: src/core_concepts/overview.md:133
msgid "Make the storage library easy to use outside of Linera"
msgstr ""

#: src/core_concepts/overview.md:135
msgid ""
"[Validator Infrastructure](https://linera.dev/core_concepts/overview."
"html#validator-infrastructure)"
msgstr ""

#: src/core_concepts/overview.md:137
msgid "Simple TCP/UDP networking (used for benchmarks only)"
msgstr ""

#: src/core_concepts/overview.md:138
msgid "GRPC networking"
msgstr ""

#: src/core_concepts/overview.md:139
msgid "Basic frontend (aka. proxy) supporting fixed internal shards"
msgstr ""

#: src/core_concepts/overview.md:140
msgid "Observability"
msgstr ""

#: src/core_concepts/overview.md:141
msgid "Initial kubernetes support in CI"
msgstr ""

#: src/core_concepts/overview.md:142
msgid "Initial deployment using a cloud provider"
msgstr ""

#: src/core_concepts/overview.md:143
msgid "New frontend to support dynamic shard assignment"
msgstr ""

#: src/core_concepts/overview.md:144
msgid "Cloud integration to demonstrate elastic scaling"
msgstr ""

#: src/core_concepts/overview.md:146
msgid "[Web3 SDK](https://linera.dev/core_concepts/overview.html#web3-sdk)"
msgstr ""

#: src/core_concepts/overview.md:148
msgid "Initial traits for contract and service interfaces"
msgstr ""

#: src/core_concepts/overview.md:149
msgid "Support for unit testing"
msgstr ""

#: src/core_concepts/overview.md:150
msgid "Support for integration testing"
msgstr ""

#: src/core_concepts/overview.md:151
msgid "Local GraphQL service to query and browse system state"
msgstr ""

#: src/core_concepts/overview.md:152
msgid "Local GraphQL service to query and browse application states"
msgstr ""

#: src/core_concepts/overview.md:153
msgid "Use GraphQL mutations to execute operations and create blocks"
msgstr ""

#: src/core_concepts/overview.md:154
msgid "Initial support for unit tests"
msgstr ""

#: src/core_concepts/overview.md:155
msgid "Support for integration tests"
msgstr ""

#: src/core_concepts/overview.md:156
msgid "Initial ABIs for contract and service interfaces"
msgstr ""

#: src/core_concepts/overview.md:157
msgid "Allowing message sender to pay for message execution fees"
msgstr ""

#: src/core_concepts/overview.md:158
msgid "Bindings to use native cryptographic primitives from Wasm"
msgstr ""

#: src/core_concepts/overview.md:159
msgid "Allowing applications to pay for user fees"
msgstr ""

#: src/core_concepts/overview.md:160
msgid "Allowing applications to use permissioned chains and public chains"
msgstr ""

#: src/core_concepts/overview.md:161
msgid "Wallet as a browser extension (no VM)"
msgstr ""

#: src/core_concepts/overview.md:162
msgid "Wallet as a browser extension (with Wasm VM)"
msgstr ""

#: src/core_concepts/microchains.md:1
msgid "2.2. Microchains"
msgstr ""

#: src/core_concepts/microchains.md:3
msgid ""
"This section provides an introduction to microchains, the main building "
"block of the Linera Protocol. For a more formal treatment refer to the "
"[whitepaper](https://linera.io/whitepaper)."
msgstr ""

#: src/core_concepts/microchains.md:5
msgid ""
"[Background](https://linera.dev/core_concepts/microchains.html#background)"
msgstr ""

#: src/core_concepts/microchains.md:7
msgid ""
"A **microchain** is a chain of blocks describing successive changes to a "
"shared state. We will use the terms _chain_ and _microchain_ "
"interchangeably. Linera microchains are similar to the familiar notion of "
"blockchain, with the following important specificities:"
msgstr ""

#: src/core_concepts/microchains.md:9
msgid ""
"An arbitrary number of microchains can coexist in a Linera network, all "
"sharing the same set of validators and the same level of security. Creating "
"a new microchain only takes one transaction on an existing chain."
msgstr ""

#: src/core_concepts/microchains.md:10
msgid ""
"The task of proposing new blocks in a microchain can be assumed either by "
"validators or by end users (or rather their wallets) depending on the "
"configuration of a chain. Specifically, microchains can be _single-owner_, "
"_permissioned_, or _public_, depending on who is authorized to propose "
"blocks."
msgstr ""

#: src/core_concepts/microchains.md:12
msgid ""
"[Cross-Chain Messaging](https://linera.dev/core_concepts/microchains."
"html#cross-chain-messaging)"
msgstr ""

#: src/core_concepts/microchains.md:14
msgid ""
"In traditional networks with a single blockchain, every transaction can "
"access the entire execution state. This is not the case in Linera where the "
"state of a microchain is only affected by its own blocks."
msgstr ""

#: src/core_concepts/microchains.md:16
msgid ""
"Cross-chain messaging is a way for different microchains to communicate with "
"each other asynchronously. This method allows applications and data to be "
"distributed across multiple chains for better scalability. When an "
"application on one chain sends a message to another chain, a cross-chain "
"request is created. These requests are implemented using remote procedure "
"calls (RPCs) within the validators' internal network, ensuring that each "
"request is executed only once."
msgstr ""

#: src/core_concepts/microchains.md:18
msgid ""
"Instead of immediately modifying the target chain, messages are placed first "
"in the target chain's **inbox**. When an owner of the target chain creates "
"its next block in the future, they may reference a selection of messages "
"taken from the current inbox in the new block. This executes the selected "
"messages and applies their messages to the chain state."
msgstr ""

#: src/core_concepts/microchains.md:20
msgid ""
"Below is an example set of chains sending asynchronous messages to each "
"other over consecutive blocks."
msgstr ""

#: src/core_concepts/microchains.md:40
msgid ""
"The Linera protocol allows receivers to discard messages but not to change "
"the ordering of selected messages inside the communication queue between two "
"chains. If a selected message fails to execute, it is skipped during the "
"execution of the receiver's block. The current implementation of the Linera "
"client always selects as many messages as possible from inboxes, and never "
"discards messages."
msgstr ""

#: src/core_concepts/microchains.md:42
msgid ""
"[Chain Ownership Semantics](https://linera.dev/core_concepts/microchains."
"html#chain-ownership-semantics)"
msgstr ""

#: src/core_concepts/microchains.md:44
msgid ""
"Only single-owner chains are currently supported in the Linera SDK. However, "
"microchains can create new microchains for other users, and control of a "
"chain can be transferred to another user by changing the owner ID. A chain "
"is permanently deactivated when its owner ID is set to `None`."
msgstr ""

#: src/core_concepts/microchains.md:46
msgid ""
"For more detail and examples on how to open and close chains, see the wallet "
"section on [chain management](https://linera.dev/core_concepts/wallets."
"html#opening-a-chain)."
msgstr ""

#: src/core_concepts/wallets.md:1
msgid "2.3. Wallets"
msgstr ""

#: src/core_concepts/wallets.md:3
msgid ""
"As in traditional blockchains, Linera wallets are in charge of holding user "
"private keys. However, instead of signing transactions, Linera wallets are "
"meant to sign blocks and propose them to extend the chains owned by their "
"users."
msgstr ""

#: src/core_concepts/wallets.md:5
msgid ""
"In practice, wallets include a node which tracks a subset of Linera chains. "
"We will see in the [next section](https://linera.dev/core_concepts/"
"node_service.html) how a Linera wallet can run a GraphQL service to expose "
"the state of its chains to web frontends."
msgstr ""

#: src/core_concepts/wallets.md:7
msgid ""
"The command-line tool `linera` is the main way for developers to interact "
"with a Linera network and manage the user wallets present locally on the "
"system."
msgstr ""

#: src/core_concepts/wallets.md:9
msgid ""
"Note that this command-line tool is intended mainly for development "
"purposes. Our goal is that end users eventually manage their wallets in a "
"[browser extension](https://linera.dev/core_concepts/overview.html#web3-sdk)."
msgstr ""

#: src/core_concepts/wallets.md:11
msgid ""
"[Selecting a Wallet](https://linera.dev/core_concepts/wallets.html#selecting-"
"a-wallet)"
msgstr ""

#: src/core_concepts/wallets.md:13
msgid ""
"The private state of a wallet is conventionally stored in a file `wallet."
"json`, while the state of its node is stored in a file `linera.db`."
msgstr ""

#: src/core_concepts/wallets.md:15
msgid ""
"To switch between wallets, you may use the `--wallet` and `--storage` "
"options of the `linera` tool, e.g. as in `linera --wallet wallet2.json --"
"storage rocksdb:linera2.db`."
msgstr ""

#: src/core_concepts/wallets.md:17
msgid ""
"You may also define the environment variables `LINERA_STORAGE` and "
"`LINERA_WALLET` to the same effect. E.g. `LINERA_STORAGE=$PWD/wallet2.json` "
"and `LINERA_WALLET=$PWD/wallet2.json`."
msgstr ""

#: src/core_concepts/wallets.md:19
msgid ""
"Finally, if `LINERA_STORAGE_$I` and `LINERA_WALLET_$I` are defined for some "
"number `I`, you may call `linera --with-wallet $I` (or `linera -w $I` for "
"short)."
msgstr ""

#: src/core_concepts/wallets.md:21
msgid ""
"[Chain Management](https://linera.dev/core_concepts/wallets.html#chain-"
"management)"
msgstr ""

#: src/core_concepts/wallets.md:23
msgid ""
"[Listing Chains](https://linera.dev/core_concepts/wallets.html#listing-"
"chains)"
msgstr ""

#: src/core_concepts/wallets.md:25
msgid ""
"To list the chains present in your wallet, you may use the command `show`:"
msgstr ""

#: src/core_concepts/wallets.md:46
msgid ""
"Each row represents a chain present in the wallet. On the left is the unique "
"identifier on the chain, and on the right is metadata for that chain "
"associated with the latest block."
msgstr ""

#: src/core_concepts/wallets.md:48
msgid ""
"[Default Chain](https://linera.dev/core_concepts/wallets.html#default-chain)"
msgstr ""

#: src/core_concepts/wallets.md:50
msgid ""
"Each wallet has a default chain that all commands apply to unless you "
"specify another `--chain` on the command line."
msgstr ""

#: src/core_concepts/wallets.md:52
msgid ""
"The default chain is set initially, when the first chain is added to the "
"wallet. You can check the default chain for your wallet by running:"
msgstr ""

#: src/core_concepts/wallets.md:58
msgid ""
"The Chain ID which is in green text instead of white text is your default "
"chain."
msgstr ""

#: src/core_concepts/wallets.md:60
msgid ""
"To change the default chain for your wallet, user the `set-default` command:"
msgstr ""

#: src/core_concepts/wallets.md:66
msgid ""
"[Opening a Chain](https://linera.dev/core_concepts/wallets.html#opening-a-"
"chain)"
msgstr ""

#: src/core_concepts/wallets.md:68
msgid ""
"The Linera protocol defines semantics for how new chains are created, we "
"call this \"opening a chain\". A chain cannot be opened in a vacuum, it "
"needs to be created by an existing chain on the network."
msgstr ""

#: src/core_concepts/wallets.md:70
msgid ""
"[Open a Chain for Your Own Wallet](https://linera.dev/core_concepts/wallets."
"html#open-a-chain-for-your-own-wallet)"
msgstr ""

#: src/core_concepts/wallets.md:72
msgid ""
"To open a chain for your own wallet, you can use the `open-chain` command:"
msgstr ""

#: src/core_concepts/wallets.md:78
msgid ""
"This will create a new chain (using the wallet's default chain) and add it "
"to the wallet. Use the `wallet show` command to see your existing chains."
msgstr ""

#: src/core_concepts/wallets.md:80
msgid ""
"[Open a Chain for Another Wallet](https://linera.dev/core_concepts/wallets."
"html#open-a-chain-for-another-wallet)"
msgstr ""

#: src/core_concepts/wallets.md:82
msgid ""
"Opening a chain for another `wallet` requires an extra two steps. Let's "
"initialize a second wallet:"
msgstr ""

#: src/core_concepts/wallets.md:88
msgid ""
"First `wallet2` must create an unassigned keypair. The public part of that "
"keypair is then sent to the `wallet` who is the chain creator."
msgstr ""

#: src/core_concepts/wallets.md:92
msgid "# this is the public key for the unassigned keypair\n"
msgstr ""

#: src/core_concepts/wallets.md:95
msgid "Next, using the public key, `wallet` can open a chain for `wallet2`."
msgstr ""

#: src/core_concepts/wallets.md:103
msgid ""
"The first line is the message ID specifying the cross-chain message that "
"creates the new chain. of the newly created chain. The second line is the "
"new chain's ID."
msgstr ""

#: src/core_concepts/wallets.md:105
msgid ""
"Finally, to add the chain to `wallet2` for the given unassigned key we use "
"the `assign` command:"
msgstr ""

#: src/core_concepts/wallets.md:111
msgid ""
"[Setting up Extra Wallets Automatically with `linera net up`](https://linera."
"dev/core_concepts/wallets.html#setting-up-extra-wallets-automatically-with-"
"linera-net-up)"
msgstr ""

#: src/core_concepts/wallets.md:113
msgid ""
"For testing, rather than using `linera open-chain` and `linera assign` as "
"above, it is often more convenient to pass the option `--extra-wallets N` to "
"`linera net up`."
msgstr ""

#: src/core_concepts/wallets.md:115
msgid ""
"This option will create create `N` additional user wallets and output Bash "
"commands to define the environment variables `LINERA_{WALLET,STORAGE}_$I` "
"where `I` ranges over `0..=N` (`I=0` being the wallet for the initial "
"chains)."
msgstr ""

#: src/core_concepts/wallets.md:117
msgid ""
"Once all the environment variables are defined, you may switch between "
"wallets using `linera --with-wallet I` or `linera -w I` for short."
msgstr ""

#: src/core_concepts/wallets.md:119
msgid ""
"[Automation in Bash](https://linera.dev/core_concepts/wallets."
"html#automation-in-bash)"
msgstr ""

#: src/core_concepts/wallets.md:121
msgid ""
"To automate the process of setting the variables `LINERA_WALLET*` and "
"`LINERA_STORAGE*` after creating a local test network in a shell, we provide "
"a Bash helper function `linera_spawn_and_read_wallet_variables`."
msgstr ""

#: src/core_concepts/wallets.md:123
msgid ""
"To define the function `linera_spawn_and_read_wallet_variables` in your "
"shell, run `source /dev/stdin <<<\"$(linera net helper 2>/dev/null)\"`. You "
"may also add the output of `linera net helper` to your `~/.bash_profile` for "
"future sessions."
msgstr ""

#: src/core_concepts/wallets.md:125
msgid ""
"Once the function is defined, call `linera_spawn_and_read_wallet_variables "
"linera net up` instead of `linera net up`."
msgstr ""

#: src/core_concepts/node_service.md:1
msgid "2.4. Node Service"
msgstr ""

#: src/core_concepts/node_service.md:3
msgid ""
"So far we've seen how to use the Linera client treating it as a binary in "
"your terminal. However, the client also acts as a node which:"
msgstr ""

#: src/core_concepts/node_service.md:5
msgid "Executes blocks"
msgstr ""

#: src/core_concepts/node_service.md:6
msgid ""
"Exposes an GraphQL API and IDE for dynamically interacting with applications "
"and the system"
msgstr ""

#: src/core_concepts/node_service.md:7
msgid ""
"Listens for notifications from validators and automatically updates local "
"chains."
msgstr ""

#: src/core_concepts/node_service.md:9
msgid "To interact with the node service, run `linera` in `service` mode:"
msgstr ""

#: src/core_concepts/node_service.md:15
msgid ""
"This will run the node service on port 8080 by default (this can be "
"overridden using the `--port` flag)."
msgstr ""

#: src/core_concepts/node_service.md:17
msgid ""
"[A Note on GraphQL](https://linera.dev/core_concepts/node_service.html#a-"
"note-on-graphql)"
msgstr ""

#: src/core_concepts/node_service.md:19
msgid ""
"Linera uses GraphQL as the query language for interfacing with different "
"parts of the system. GraphQL enables clients to craft queries such that they "
"receive exactly what they want and nothing more."
msgstr ""

#: src/core_concepts/node_service.md:21
msgid ""
"GraphQL is used extensively during application development, especially to "
"query the state of an application from a front-end for example."
msgstr ""

#: src/core_concepts/node_service.md:23
msgid ""
"To learn more about GraphQL check out the [official docs](https://graphql."
"org/learn/)."
msgstr ""

#: src/core_concepts/node_service.md:25
msgid ""
"[GraphiQL IDE](https://linera.dev/core_concepts/node_service.html#graphiql-"
"ide)"
msgstr ""

#: src/core_concepts/node_service.md:27
msgid ""
"Conveniently, the node service exposes a GraphQL IDE called GraphiQL. To use "
"GraphiQL start the node service and navigate to `localhost:8080/`."
msgstr ""

#: src/core_concepts/node_service.md:29
msgid ""
"Using the schema explorer on the left of the GraphiQL IDE you can "
"dynamically explore the state of the system and your applications."
msgstr ""

#: src/core_concepts/node_service.md:31
msgid "![graphiql.png](node_service.assets/graphiql.png)"
msgstr ""

#: src/core_concepts/node_service.md:33
msgid ""
"[GraphQL System API](https://linera.dev/core_concepts/node_service."
"html#graphql-system-api)"
msgstr ""

#: src/core_concepts/node_service.md:35
msgid ""
"The node service also exposes a GraphQL API which corresponds to the set of "
"system operations. You can explore the full set of operations by clicking on "
"`MutationRoot`."
msgstr ""

#: src/core_concepts/node_service.md:37
msgid ""
"[GraphQL Application API](https://linera.dev/core_concepts/node_service."
"html#graphql-application-api)"
msgstr ""

#: src/core_concepts/node_service.md:39
msgid ""
"To interact with an application, we run the Linera client in service mode. "
"It exposes a GraphQL API for every application running on any owned chain at "
"`localhost:8080/chains/<chain-id>/applications/<application-id>`."
msgstr ""

#: src/core_concepts/node_service.md:41
msgid ""
"Navigating there with your browser will open a GraphiQL interface which "
"enables you to graphically explore the state of your application."
msgstr ""

#: src/core_concepts/applications.md:1
msgid "2.5. Applications"
msgstr ""

#: src/core_concepts/applications.md:3
msgid ""
"The programming model of Linera is designed so that developers can take "
"advantage of microchains to scale their applications."
msgstr ""

#: src/core_concepts/applications.md:5
msgid ""
"Linera uses the WebAssembly Virtual Machine (Wasm) to execute user "
"applications. Currently, the [Linera SDK](https://linera.dev/sdk.html) is "
"focused on the [Rust](https://www.rust-lang.org/) programming language."
msgstr ""

#: src/core_concepts/applications.md:7
msgid ""
"Linera applications are structured using the familiar notion of **Rust "
"crate**: the external interfaces of an application (including initialization "
"parameters, operations, messages, and cross-application calls) generally go "
"into the library part of its crate, while the core of each application is "
"compiled into binary files for the Wasm architecture."
msgstr ""

#: src/core_concepts/applications.md:9
msgid ""
"[The Application Deployment Lifecycle](https://linera.dev/core_concepts/"
"applications.html#the-application-deployment-lifecycle)"
msgstr ""

#: src/core_concepts/applications.md:11
msgid ""
"Linera Applications are designed to be powerful yet re-usable. For this "
"reason there is a distinction between the bytecode and an application "
"instance on the network."
msgstr ""

#: src/core_concepts/applications.md:13
msgid ""
"Applications undergo a lifecycle transition aimed at making development easy "
"and flexible:"
msgstr ""

#: src/core_concepts/applications.md:15
msgid ""
"The bytecode is built from a Rust project with the `linera-sdk` dependency."
msgstr ""

#: src/core_concepts/applications.md:16
msgid ""
"The bytecode is published to the network on a microchain, and assigned an "
"identifier."
msgstr ""

#: src/core_concepts/applications.md:17
msgid ""
"A user can create a new application instance, by providing the bytecode "
"identifier and initialization arguments. This process returns an application "
"identifier which can be used to reference and interact with the application."
msgstr ""

#: src/core_concepts/applications.md:18
msgid ""
"The same bytecode identifier can be used as many times is needed by as many "
"users are needed to create distinct applications."
msgstr ""

#: src/core_concepts/applications.md:20
msgid ""
"Importantly, the application deployment lifecycle is abstracted from the "
"user, and an application can be published with a single command:"
msgstr ""

#: src/core_concepts/applications.md:26
msgid ""
"This will publish the bytecode as well as initialize the application for you."
msgstr ""

#: src/core_concepts/applications.md:28
msgid ""
"[Anatomy of an Application](https://linera.dev/core_concepts/applications."
"html#anatomy-of-an-application)"
msgstr ""

#: src/core_concepts/applications.md:30
msgid ""
"An **application** is broken into two major components, the _contract_ and "
"the _service_."
msgstr ""

#: src/core_concepts/applications.md:32
msgid ""
"The **contract** is gas-metered, and is the part of the application which "
"executes operations and messages, make cross-application calls and modifies "
"the application's state. The details are covered in more depth in the [SDK "
"docs](https://linera.dev/sdk.html)."
msgstr ""

#: src/core_concepts/applications.md:34
msgid ""
"The **service** is non-metered and read-only. It is used primarily to query "
"the state of an application and populate the presentation layer (think front-"
"end) with the data required for a user interface."
msgstr ""

#: src/core_concepts/applications.md:36
msgid ""
"Finally, the application's state is shared by the contract and service in "
"the form of a [View](https://linera.dev/advanced_topics/views.html), but "
"more on that later."
msgstr ""

#: src/core_concepts/applications.md:38
msgid ""
"[Operations and Messages](https://linera.dev/core_concepts/applications."
"html#operations-and-messages)"
msgstr ""

#: src/core_concepts/applications.md:40
msgid ""
"For this section we'll be using a simplified version of the example "
"application called \"fungible\" where users can send tokens to each other."
msgstr ""

#: src/core_concepts/applications.md:42
msgid ""
"At the system-level, interacting with an application can be done via "
"operations and messages."
msgstr ""

#: src/core_concepts/applications.md:44
msgid ""
"**Operations** are defined by an application developer and each application "
"can have a completely different set of operations. Chain owners then "
"actively create operations and put them in their block proposals to interact "
"with an application."
msgstr ""

#: src/core_concepts/applications.md:46
msgid ""
"Taking the \"fungible token\" application as an example, an operation for a "
"user to transfer funds to another user would look like this:"
msgstr ""

#: src/core_concepts/applications.md:51
msgid ""
"/// A transfer from a (locally owned) account to a (possibly remote) "
"account.\n"
msgstr ""

#: src/core_concepts/applications.md:57 src/core_concepts/applications.md:69
msgid "// Meant to be extended here\n"
msgstr ""

#: src/core_concepts/applications.md:61
msgid ""
"**Messages** result from the execution of operations or other messages. "
"Messages can be sent from one chain to another. Block proposers also "
"actively include messages in their block proposal, but unlike with "
"operations, they are only allowed to include them in the right order "
"(possibly skipping some), and only if they were actually created by another "
"chain (or the same chain, earlier)."
msgstr ""

#: src/core_concepts/applications.md:63
msgid ""
"In our \"fungible token\" application, a message to credit an account would "
"look like this:"
msgstr ""

#: src/core_concepts/applications.md:73
msgid ""
"[Authentication](https://linera.dev/core_concepts/applications."
"html#authentication)"
msgstr ""

#: src/core_concepts/applications.md:75
msgid ""
"Operations are always authenticated and messages may be authenticated. The "
"signer of a block becomes the authenticator of all the operations in that "
"block. As operations are executed by applications, messages can be created "
"to be sent to other chains. When they are created, they can be configured to "
"be authenticated. In that case, the message receives the same authentication "
"as the operation that created it. If handling an incoming message creates "
"new messages, those may also be configured to have the same authentication "
"as the received message."
msgstr ""

#: src/core_concepts/applications.md:77
msgid ""
"In other words, the block signer can have its authority propagated across "
"chains through series of messages. This allows applications to safely store "
"user state in chains that the user may not have the authority to produce "
"blocks. The application may also allow only the authorized user to change "
"that state, and not even the chain owner is able to override that."
msgstr ""

#: src/core_concepts/applications.md:79
msgid ""
"The figure below shows four chains (A, B, C, D) and some blocks produced in "
"them. In this example, each chain is owned by a single owner (aka. address). "
"Owners are in charge of producing blocks and sign new blocks using their "
"signing keys. Some blocks show the operations and incoming messages they "
"accept, where the authentication is shown inside parenthesis. All operations "
"produced are authenticated by the block proposer, and if these are all "
"single user chains, the proposer is always the chain owner. Messages that "
"have authentication use the one from the operation or message that created "
"it."
msgstr ""

#: src/core_concepts/applications.md:81
msgid ""
"One example in the figure is that chain A produced a block with Operation 1, "
"which is authenticated by the owner of chain A (written `(a)`). That "
"operations sent a message to chain B, and assuming the message was sent with "
"the authentication forwarding enabled, it is received and executed in chain "
"B with the authentication of `(a)`. Another example is that chain D produced "
"a block with Operation 2, which is authenticated by the owner of chain D "
"(written `(d)`). That operation sent a message to chain C, which is executed "
"with authentication of `(d)` like the example before. Handling that message "
"in chain C produced a new message, which was sent to chain B. That message, "
"when received by chain B is executed with the authentication of `(d)`."
msgstr ""

#: src/core_concepts/applications.md:109
msgid ""
"An example where this is used is in the Fungible application, where a "
"`Claim` operation allows retrieving money from a chain the user does not "
"control (but the user still trusts will produce a block receiving their "
"message). Without the `Claim` operation, users would only be able to store "
"their tokens on their own chains, and multi-owner and public chains would "
"have their tokens shared between anyone able to produce a block."
msgstr ""

#: src/core_concepts/applications.md:111
msgid ""
"With the `Claim` operation, users can store their tokens on another chain "
"where they're able to produce blocks or where they trust the owner will "
"produce blocks receiving their messages. Only they are able to move their "
"tokens, even on chains where ownership is shared or where they are not able "
"to produce blocks."
msgstr ""

#: src/core_concepts/applications.md:113
msgid ""
"[Registering an Application across Chains](https://linera.dev/core_concepts/"
"applications.html#registering-an-application-across-chains)"
msgstr ""

#: src/core_concepts/applications.md:115
msgid ""
"If Alice is using an application on her chain and starts interacting with "
"Bob via the application, e.g. sends him some tokens using the `fungible` "
"example, the application automatically gets registered on Bob's chain, too, "
"as soon as he handles the incoming cross-chain messages. After that, he can "
"execute the application's operations on his chain, too, and e.g. send tokens "
"to someone."
msgstr ""

#: src/core_concepts/applications.md:117
msgid ""
"But there are also cases where Bob may want to start using an application he "
"doesn't have yet. E.g. maybe Alice regularly makes posts using the `social` "
"example, and Bob wants to subscribe to her."
msgstr ""

#: src/core_concepts/applications.md:119
msgid ""
"In that case, trying to execute an application-specific operation would "
"fail, because the application is not registered on his chain. He needs to "
"request it from Alice first:"
msgstr ""

#: src/core_concepts/applications.md:125
msgid ""
"Once Alice processes his message (which happens automatically if she is "
"running the client in service mode), he can start using the application."
msgstr ""

#: src/sdk.md:3
msgid ""
"In this section, we'll be exploring how to create Web3 applications using "
"the Linera SDK."
msgstr ""

#: src/sdk.md:5
msgid "We'll use a simple \"counter\" application as a running example."
msgstr ""

#: src/sdk.md:7
msgid ""
"We'll focus on the back end of the application, which consists of two main "
"parts: a _smart contract_ and its GraphQL service."
msgstr ""

#: src/sdk.md:9
msgid ""
"Both the contract and the service of an application are written in Rust "
"using the crate [`linera-sdk`](https://crates.io/crates/linera-sdk), and "
"compiled to Wasm bytecode."
msgstr ""

#: src/sdk.md:11
msgid ""
"This section should be seen as a guide versus a reference manual for the "
"SDK. For the reference manual, refer to the [documentation of the crate]"
"(https://docs.rs/linera-sdk/latest/linera_sdk/)."
msgstr ""

#: src/sdk/creating_a_project.md:1
msgid "3.1. Creating a Project"
msgstr ""

#: src/sdk/creating_a_project.md:3
msgid ""
"To create your Linera project, use the `linera project new` command. The "
"command should be executed outside the `linera-protocol` folder. It sets up "
"the scaffolding and requisite files:"
msgstr ""

#: src/sdk/creating_a_project.md:9
msgid ""
"`linera project new` bootstraps your project by creating the following key "
"files:"
msgstr ""

#: src/sdk/creating_a_project.md:11
msgid ""
"`Cargo.toml`: your project's manifest filled with the necessary dependencies "
"to create an app;"
msgstr ""

#: src/sdk/creating_a_project.md:12
msgid "`src/lib.rs`: the application's ABI definition;"
msgstr ""

#: src/sdk/creating_a_project.md:13
msgid "`src/state.rs`: the application's state;"
msgstr ""

#: src/sdk/creating_a_project.md:14
msgid ""
"`src/contract.rs`: the application's contract, and the binary target for the "
"contract bytecode;"
msgstr ""

#: src/sdk/creating_a_project.md:15
msgid ""
"`src/service.rs`: the application's service, and the binary target for the "
"service bytecode."
msgstr ""

#: src/sdk/creating_a_project.md:16
msgid ""
"`.cargo/config.toml`: modifies the default target used by `cargo` to be "
"`wasm32-unknown-unknown`"
msgstr ""

#: src/sdk/state.md:1
msgid "3.2. Creating the Application State"
msgstr ""

#: src/sdk/state.md:3
msgid ""
"The `struct` which defines your application's state can be found in `src/"
"state.rs`."
msgstr ""

#: src/sdk/state.md:5
msgid ""
"To represent our counter, we're going to need a single `u64`. To persist the "
"counter we'll be using Linera's [view](https://linera.dev/advanced_topics/"
"views.html) paradigm."
msgstr ""

#: src/sdk/state.md:7
msgid ""
"Views are a little like an [ORM](https://en.wikipedia.org/wiki/Object–"
"relational_mapping), however instead of mapping data structures to a "
"relational database like Postgres, they are instead mapped onto key-value "
"stores like [RocksDB](https://rocksdb.org/)."
msgstr ""

#: src/sdk/state.md:9
msgid "In vanilla Rust, we might represent our Counter as so:"
msgstr ""

#: src/sdk/state.md:12
msgid "// do not use this\n"
msgstr ""

#: src/sdk/state.md:18
msgid ""
"However, to persist your data, you'll need to replace the existing "
"`Application` state struct in `src/state.rs` with the following view:"
msgstr ""

#: src/sdk/state.md:21
msgid "/// The application state.\n"
msgstr ""

#: src/sdk/state.md:23
msgid "\"ViewStorageContext\""
msgstr ""

#: src/sdk/state.md:29
msgid "and all other occurrences of `Application` in your app."
msgstr ""

#: src/sdk/state.md:31
msgid ""
"The `RegisterView<T>` supports modifying a single value of type `T`. There "
"are different types of views for different use-cases, but the majority of "
"common data structures have already been implemented:"
msgstr ""

#: src/sdk/state.md:33
msgid "A `Vec` or `VecDeque` corresponds to a `LogView`"
msgstr ""

#: src/sdk/state.md:34
msgid ""
"A `BTreeMap` corresponds to a `MapView` if its values are primitive, or to "
"`CollectionView` if its values are other views;"
msgstr ""

#: src/sdk/state.md:35
msgid "A `Queue` corresponds to a `QueueView`"
msgstr ""

#: src/sdk/state.md:37
msgid ""
"For an exhaustive list refer to the Views [documentation](https://linera.dev/"
"advanced_topics/views.html)."
msgstr ""

#: src/sdk/state.md:39
msgid "Finally, run `cargo check` to ensure that your changes compile."
msgstr ""

#: src/sdk/abi.md:1
msgid "3.3. Defining the ABI"
msgstr ""

#: src/sdk/abi.md:3
msgid ""
"The Application Binary Interface (ABI) of a Linera application defines how "
"to interact with this application from other parts of the system. It "
"includes the data structures, data types, and functions exposed by on-chain "
"contracts and services."
msgstr ""

#: src/sdk/abi.md:5
msgid ""
"ABIs are usually defined in `src/lib.rs` and compiled across all "
"architectures (Wasm and native)."
msgstr ""

#: src/sdk/abi.md:7
msgid ""
"For a reference guide, check out the [documentation of the crate](https://"
"docs.rs/linera-base/latest/linera_base/abi/)."
msgstr ""

#: src/sdk/abi.md:9
msgid ""
"[Defining a marker struct](https://linera.dev/sdk/abi.html#defining-a-marker-"
"struct)"
msgstr ""

#: src/sdk/abi.md:11
msgid ""
"The library part of your application (generally in `src/lib.rs`) must define "
"a public empty struct that implements the `Abi` trait."
msgstr ""

#: src/sdk/abi.md:17
msgid ""
"The `Abi` trait combines the `ContractAbi` and `ServiceAbi` traits to "
"include the types that your application exports."
msgstr ""

#: src/sdk/abi.md:20
msgid ""
"/// A trait that includes all the types exported by a Linera application "
"(both contract\n"
"/// and service).\n"
msgstr ""

#: src/sdk/abi.md:25
msgid "Next, we're going to implement each of the two traits."
msgstr ""

#: src/sdk/abi.md:27
msgid "[Contract ABI](https://linera.dev/sdk/abi.html#contract-abi)"
msgstr ""

#: src/sdk/abi.md:29
msgid ""
"The `ContractAbi` trait defines the data types that your application uses in "
"a contract. Each type represents a specific part of the contract's behavior:"
msgstr ""

#: src/sdk/abi.md:32
msgid ""
"/// A trait that includes all the types exported by a Linera application "
"contract.\n"
msgstr ""

#: src/sdk/abi.md:34 src/sdk/abi.md:101
msgid ""
"/// Immutable parameters specific to this application (e.g. the name of a "
"token).\n"
msgstr ""

#: src/sdk/abi.md:37
msgid ""
"/// Initialization argument passed to a new application on the chain that "
"created it\n"
"    /// (e.g. an initial amount of tokens minted).\n"
"    ///\n"
"    /// To share configuration data on every chain, use [`ContractAbi::"
"Parameters`]\n"
"    /// instead.\n"
msgstr ""

#: src/sdk/abi.md:44
msgid ""
"/// The type of operation executed by the application.\n"
"    ///\n"
"    /// Operations are transactions directly added to a block by the creator "
"(and signer)\n"
"    /// of the block. Users typically use operations to start interacting "
"with an\n"
"    /// application on their own chain.\n"
msgstr ""

#: src/sdk/abi.md:51
msgid ""
"/// The type of message executed by the application.\n"
"    ///\n"
"    /// Messages are executed when a message created by the same application "
"is received\n"
"    /// from another chain and accepted in a block.\n"
msgstr ""

#: src/sdk/abi.md:57
msgid ""
"/// The argument type when this application is called from another "
"application on the same chain.\n"
msgstr ""

#: src/sdk/abi.md:60
msgid ""
"/// The argument type when a session of this application is called from "
"another\n"
"    /// application on the same chain.\n"
"    ///\n"
"    /// Sessions are temporary objects that may be spawned by an application "
"call. Once\n"
"    /// created, they must be consumed before the current transaction ends.\n"
msgstr ""

#: src/sdk/abi.md:67
msgid "/// The type for the state of a session.\n"
msgstr ""

#: src/sdk/abi.md:70
msgid "/// The response type of an application call.\n"
msgstr ""

#: src/sdk/abi.md:75
msgid ""
"All these types must implement the `Serialize`, `DeserializeOwned`, `Send`, "
"`Sync`, `Debug` traits, and have a `'static` lifetime."
msgstr ""

#: src/sdk/abi.md:77
msgid ""
"In our example, we would like to change our `InitializationArgument`, "
"`Operation` to `u64`, like so:"
msgstr ""

#: src/sdk/abi.md:92
msgid "[Service ABI](https://linera.dev/sdk/abi.html#service-abi)"
msgstr ""

#: src/sdk/abi.md:94
msgid ""
"The `ServiceAbi` is in principle very similar to the `ContractAbi`, just for "
"the service component of your application."
msgstr ""

#: src/sdk/abi.md:96
msgid ""
"The `ServiceAbi` trait defines the types used by the service part of your "
"application:"
msgstr ""

#: src/sdk/abi.md:99
msgid ""
"/// A trait that includes all the types exported by a Linera application "
"service.\n"
msgstr ""

#: src/sdk/abi.md:104
msgid "/// The type of a query receivable by the application's service.\n"
msgstr ""

#: src/sdk/abi.md:107
msgid "/// The response type of the application's service.\n"
msgstr ""

#: src/sdk/abi.md:112
msgid ""
"For our Counter example, we'll be using GraphQL to query our application so "
"our `ServiceAbi` should reflect that:"
msgstr ""

#: src/sdk/contract.md:1
msgid "3.4. Writing the Contract Binary"
msgstr ""

#: src/sdk/contract.md:3
msgid ""
"The contract binary is the first component of a Linera application. It can "
"actually change the state of the application."
msgstr ""

#: src/sdk/contract.md:5
msgid ""
"To create a contract, we need to implement the `Contract` trait, which is as "
"follows:"
msgstr ""

#: src/sdk/contract.md:10
msgid "/// The type used to report errors to the execution environment.\n"
msgstr ""

#: src/sdk/contract.md:13 src/sdk/service.md:16
msgid ""
"/// The desired storage backend used to store the application's state.\n"
msgstr ""

#: src/sdk/contract.md:16
msgid "/// Initializes the application on the chain that created it.\n"
msgstr ""

#: src/sdk/contract.md:23
msgid "/// Applies an operation from the current block.\n"
msgstr ""

#: src/sdk/contract.md:30
msgid "/// Applies a message originating from a cross-chain message.\n"
msgstr ""

#: src/sdk/contract.md:37
msgid "/// Handles a call from another application.\n"
msgstr ""

#: src/sdk/contract.md:45
msgid "/// Handles a call into a session created by this application.\n"
msgstr ""

#: src/sdk/contract.md:57
msgid ""
"The full trait definition can be found [here](https://github.com/linera-io/"
"linera-protocol/blob/main/linera-sdk/src/lib.rs)."
msgstr ""

#: src/sdk/contract.md:59
msgid ""
"There's quite a bit going on here, so let's break it down and take one "
"method at a time."
msgstr ""

#: src/sdk/contract.md:61
msgid ""
"For this application, we'll be using the `initialize` and "
"`execute_operation` methods."
msgstr ""

#: src/sdk/contract.md:63
msgid ""
"[Initializing our Application](https://linera.dev/sdk/contract."
"html#initializing-our-application)"
msgstr ""

#: src/sdk/contract.md:65
msgid ""
"The first thing we need to do is initialize our application by using "
"`Contract::initialize`."
msgstr ""

#: src/sdk/contract.md:67
msgid ""
"`Contract::initialize` is only called once when the application is created "
"and only on the microchain that created the application."
msgstr ""

#: src/sdk/contract.md:69
msgid ""
"Deployment on other microchains will use the `Default` implementation of the "
"application state if `SimpleStateStorage` is used, or the `Default` value of "
"all sub-views in the state if the `ViewStateStorage` is used."
msgstr ""

#: src/sdk/contract.md:71
msgid ""
"For our example application, we'll want to initialize the state of the "
"application to an arbitrary number that can be specified on application "
"creation using its initialization parameters:"
msgstr ""

#: src/sdk/contract.md:84
msgid ""
"[Implementing the Increment Operation](https://linera.dev/sdk/contract."
"html#implementing-the-increment-operation)"
msgstr ""

#: src/sdk/contract.md:86
msgid ""
"Now that we have our counter's state and a way to initialize it to any value "
"we would like, a way to increment our counter's value. Changes made by block "
"proposers to application states are broadly called 'operations'."
msgstr ""

#: src/sdk/contract.md:88
msgid ""
"To create a new operation, we need to use the method `Contract::"
"execute_operation`. In the counter's case, it will be receiving a `u64` "
"which is used to increment the counter:"
msgstr ""

#: src/sdk/contract.md:102
msgid ""
"[Declaring the ABI](https://linera.dev/sdk/contract.html#declaring-the-abi)"
msgstr ""

#: src/sdk/contract.md:104
msgid ""
"Finally, to link our `Contract` trait implementation with the ABI of the "
"application, the following code is added:"
msgstr ""

#: src/sdk/service.md:1
msgid "3.5. Writing the Service Binary"
msgstr ""

#: src/sdk/service.md:3
msgid ""
"The service binary is the second component of a Linera application. It is "
"compiled into a separate Bytecode from the contract and is run "
"independently. It is not metered (meaning that querying an application's "
"service does not consume gas), and can be thought of as a read-only view "
"into your application."
msgstr ""

#: src/sdk/service.md:5
msgid ""
"Application states can be arbitrarily complex, and most of the time you "
"don't want to expose this state in its entirety to those who would like to "
"interact with your app. Instead, you might prefer to define a distinct set "
"of queries that can be made against your application."
msgstr ""

#: src/sdk/service.md:7
msgid ""
"The `Service` trait is how you define the interface into your application. "
"The `Service` trait is defined as follows:"
msgstr ""

#: src/sdk/service.md:10
msgid "/// The service interface of a Linera application.\n"
msgstr ""

#: src/sdk/service.md:13
msgid "/// Type used to report errors to the execution environment.\n"
msgstr ""

#: src/sdk/service.md:19
msgid "/// Executes a read-only query on the state of this application.\n"
msgstr ""

#: src/sdk/service.md:28
msgid ""
"The full service trait definition can be found [here](https://github.com/"
"linera-io/linera-protocol/blob/main/linera-sdk/src/lib.rs)."
msgstr ""

#: src/sdk/service.md:30
msgid "Let's implement `Service` for our counter application."
msgstr ""

#: src/sdk/service.md:32
msgid ""
"First, we want to generate the necessary boilerplate for implementing the "
"service [WIT interface](https://component-model.bytecodealliance.org/design/"
"wit.html), export the necessary resource types and functions so that the "
"host (the process running the bytecode) can call the service. Happily, there "
"is a macro to perform this code generation, so just add the following to "
"`service.rs`:"
msgstr ""

#: src/sdk/service.md:38
msgid ""
"Next, we need to implement the `Service` for `Counter`. To do this we need "
"to define `Service`'s associated types and implement `handle_query`, as well "
"as define the `Error` type:"
msgstr ""

#: src/sdk/service.md:52 src/sdk/service.md:54
msgid "// implemented in the next section\n"
msgstr ""

#: src/sdk/service.md:62
msgid "/// An error that can occur during the contract execution.\n"
msgstr ""

#: src/sdk/service.md:66
msgid "/// Invalid query argument; could not deserialize GraphQL request.\n"
msgstr ""

#: src/sdk/service.md:67
msgid "\"Invalid query argument; could not deserialize GraphQL request\""
msgstr ""

#: src/sdk/service.md:72
msgid ""
"Finally, as before, the following code is needed to incorporate the ABI "
"definitions into your `Service` implementation:"
msgstr ""

#: src/sdk/service.md:80
msgid ""
"[Adding GraphQL compatibility](https://linera.dev/sdk/service.html#adding-"
"graphql-compatibility)"
msgstr ""

#: src/sdk/service.md:82
msgid ""
"Finally, we want our application to have GraphQL compatibility. To achieve "
"this we need a `QueryRoot` for intercepting queries and a `MutationRoot` for "
"introspection queries for mutations."
msgstr ""

#: src/sdk/service.md:106
msgid ""
"We haven't included the imports in the above code; they are left as an "
"exercise to the reader (but remember to import `async_graphql::Object`). If "
"you want the full source code and associated tests check out the [examples "
"section](https://github.com/linera-io/linera-protocol/blob/main/examples/"
"counter/src/service.rs) on GitHub."
msgstr ""

#: src/sdk/deploy.md:1
msgid "3.6. Deploying the Application"
msgstr ""

#: src/sdk/deploy.md:3
msgid ""
"The first step to deploy your application is to configure a wallet. This "
"will determine where the application will be deployed: either to a local net "
"or to the devnet."
msgstr ""

#: src/sdk/deploy.md:5
msgid "[Local Net](https://linera.dev/sdk/deploy.html#local-net)"
msgstr ""

#: src/sdk/deploy.md:7
msgid ""
"To configure the local network, follow the steps in the [Getting Started "
"section](https://linera.dev/getting_started/hello_linera.html#using-the-"
"initial-test-wallet)."
msgstr ""

#: src/sdk/deploy.md:9
msgid ""
"Afterwards, the `LINERA_WALLET` and the `LINERA_STORAGE` environment "
"variables should be set and can be used in the `publish-and-create` command "
"to deploy the application while also specifying:"
msgstr ""

#: src/sdk/deploy.md:21
msgid "[Devnet](https://linera.dev/sdk/deploy.html#devnet)"
msgstr ""

#: src/sdk/deploy.md:23
msgid ""
"To configure the wallet for the devnet while creating a new microchain, the "
"following command can be used:"
msgstr ""

#: src/sdk/deploy.md:29
msgid ""
"The Faucet will provide the new chain with some tokens, which can then be "
"used to deploy the application with the `publish-and-create` command. It "
"requires specifying:"
msgstr ""

#: src/sdk/deploy.md:41
msgid ""
"[Interacting with the Application](https://linera.dev/sdk/deploy."
"html#interacting-with-the-application)"
msgstr ""

#: src/sdk/deploy.md:43
msgid ""
"To interact with the deployed application, a [node service](https://linera."
"dev/core_concepts/node_service.html) must be used."
msgstr ""

#: src/sdk/messages.md:1
msgid "3.7. Cross-Chain Messages"
msgstr ""

#: src/sdk/messages.md:3
msgid ""
"On Linera, applications are meant to be multi-chain: They are instantiated "
"on every chain where they are used. An application has the same application "
"ID and bytecode everywhere, but a separate state on every chain. To "
"coordinate, the instances can send _cross-chain messages_ to each other. A "
"message sent by an application is always handled by the _same_ application "
"on the target chain: The handling code is guaranteed to be the same as the "
"sending code, but the state may be different."
msgstr ""

#: src/sdk/messages.md:5
msgid ""
"For your application, you can specify any serializable type as the `Message` "
"type in your `ContractAbi` implementation. To send a message, return it "
"among the [`ExecutionOutcome`](https://docs.rs/linera-sdk/latest/linera_sdk/"
"struct.ExecutionOutcome.html)'s `messages`:"
msgstr ""

#: src/sdk/messages.md:11
msgid ""
"`OutgoingMessage`'s `destination` field specifies either a single "
"destination chain, or a channel, so that it gets sent to all subscribers."
msgstr ""

#: src/sdk/messages.md:13
msgid ""
"If the `authenticated` field is `true`, the callee is allowed to perform "
"actions that require authentication on behalf of the signer of the original "
"block that caused this call."
msgstr ""

#: src/sdk/messages.md:15
msgid ""
"The `message` field contains the message itself, of the type you specified "
"in the `ContractAbi`."
msgstr ""

#: src/sdk/messages.md:17
msgid ""
"You can also use [`ExecutionOutcome::with_message`](https://docs.rs/linera-"
"sdk/latest/linera_sdk/struct.ExecutionOutcome.html#method.with_message) and "
"[`with_authenticated_message`](https://docs.rs/linera-sdk/latest/linera_sdk/"
"struct.ExecutionOutcome.html#method.with_authenticated_message) for "
"convenience."
msgstr ""

#: src/sdk/messages.md:19
msgid ""
"During block execution in the _sending_ chain, messages are returned via "
"`ExecutionOutcome`s. The returned message is then placed in the _target_ "
"chain inbox for processing. There is no guarantee that it will be handled: "
"For this to happen, an owner of the target chain needs to include it in the "
"`incoming_messages` in one of their blocks. When that happens, the "
"contract's `execute_message` method gets called on their chain."
msgstr ""

#: src/sdk/messages.md:21
msgid ""
"[Example: Fungible Token](https://linera.dev/sdk/messages.html#example-"
"fungible-token)"
msgstr ""

#: src/sdk/messages.md:23
msgid ""
"In the [`fungible` example application](https://github.com/linera-io/linera-"
"protocol/tree/main/examples/fungible), such a message can be the transfer of "
"tokens from one chain to another. If the sender includes a `Transfer` "
"operation on their chain, it decreases their account balance and sends a "
"`Credit` message to the recipient's chain:"
msgstr ""

#: src/sdk/messages.md:37 src/sdk/messages.md:45 src/sdk/messages.md:63
msgid "// ...\n"
msgstr ""

#: src/sdk/messages.md:50
msgid ""
"On the recipient's chain, `execute_message` is called, which increases their "
"account balance."
msgstr ""

#: src/sdk/composition.md:1
msgid "3.8. Calling other Applications"
msgstr ""

#: src/sdk/composition.md:3
msgid ""
"We have seen that cross-chain messages sent by an application on one chain "
"are always handled by the _same_ application on the target chain."
msgstr ""

#: src/sdk/composition.md:5
msgid ""
"This section is about calling other applications using _cross-application "
"calls_."
msgstr ""

#: src/sdk/composition.md:7
msgid ""
"Such calls happen on the same chain and typically use the `call_application` "
"method implemented by default in the trait `Contract`:"
msgstr ""

#: src/sdk/composition.md:19
msgid ""
"The `authenticated` argument specifies whether the callee is allowed to "
"perform actions that require authentication on behalf of the signer of the "
"original block that caused this call."
msgstr ""

#: src/sdk/composition.md:21
msgid ""
"The `application` argument is the callee's application ID, and `A` is the "
"callee's ABI."
msgstr ""

#: src/sdk/composition.md:23
msgid ""
"`call` are the arguments of the application call, in a type defined by the "
"callee."
msgstr ""

#: src/sdk/composition.md:25
msgid ""
"`forwarded_sessions` are session data that need to be consumed within this "
"transaction. Sessions will be explained in a separate section."
msgstr ""

#: src/sdk/composition.md:27
msgid ""
"[Example: Crowd-Funding](https://linera.dev/sdk/composition.html#example-"
"crowd-funding)"
msgstr ""

#: src/sdk/composition.md:29
msgid ""
"The `crowd-funding` example application allows the application creator to "
"launch a campaign with a funding target. That target can be an amount "
"specified in any type of token based on the `fungible` application. Others "
"can then pledge tokens of that type to the campaign, and if the target is "
"not reached by the deadline, they are refunded."
msgstr ""

#: src/sdk/composition.md:31
msgid ""
"If Alice used the `fungible` example to create a Pugecoin application (with "
"an impressionable pug as its mascot), then Bob can create a `crowd-funding` "
"application, use Pugecoin's application ID as `CrowdFundingAbi::Parameters`, "
"and specify in `CrowdFundingAbi::InitializationArgument` that his campaign "
"will run for one week and has a target of 1000 Pugecoins."
msgstr ""

#: src/sdk/composition.md:33
msgid ""
"Now let's say Carol wants to pledge 10 Pugecoin tokens to Bob's campaign."
msgstr ""

#: src/sdk/composition.md:35
msgid ""
"First she needs to make sure she has his crowd-funding application on her "
"chain, e.g. using the `linera request-application` command. This will "
"automatically also register Alice's application on her chain, because it is "
"a dependency of Bob's."
msgstr ""

#: src/sdk/composition.md:37
msgid ""
"Now she can make her pledge by running the `linera service` and making a "
"query to Bob's application:"
msgstr ""

#: src/sdk/composition.md:40
msgid "\"User:841…6c0\""
msgstr ""

#: src/sdk/composition.md:40
msgid "\"10\""
msgstr ""

#: src/sdk/composition.md:43
msgid ""
"This will add a block to Carol's chain containing the pledge operation that "
"gets handled by `CrowdFunding::execute_operation`, resulting in one cross-"
"application call and two cross-chain messages:"
msgstr ""

#: src/sdk/composition.md:45
msgid ""
"First `CrowdFunding::execute_operation` calls the `fungible` application on "
"Carol's chain to transfer 10 tokens to Carol's account on Bob's chain:"
msgstr ""

#: src/sdk/composition.md:49
msgid "// The call is authenticated by Carol, who signed this block.\n"
msgstr ""

#: src/sdk/composition.md:50
msgid "// The Pugecoin application ID.\n"
msgstr ""

#: src/sdk/composition.md:52
msgid "// Carol\n"
msgstr ""

#: src/sdk/composition.md:53
msgid "// 10 tokens\n"
msgstr ""

#: src/sdk/composition.md:54
msgid "// Bob's chain.\n"
msgstr ""

#: src/sdk/composition.md:60
msgid ""
"This causes `Fungible::handle_application_call` to be run, which will create "
"a cross-chain message sending the amount 10 to the Pugecoin application "
"instance on Bob's chain."
msgstr ""

#: src/sdk/composition.md:62
msgid ""
"After the cross-application call returns, `CrowdFunding::execute_operation` "
"continues to create another cross-chain message `crowd_funding::Message::"
"PledgeWithAccount`, which informs the crowd-funding application on Bob's "
"chain that the 10 tokens are meant for the campaign."
msgstr ""

#: src/sdk/composition.md:64
msgid ""
"When Bob now adds a block to his chain that handles the two incoming "
"messages, first `Fungible::execute_message` gets executed, and then "
"`CrowdFunding::execute_message`. The latter makes another cross-application "
"call to transfer the 10 tokens from Carol's account to the crowd-funding "
"application's account (both on Bob's chain). That is successful because "
"Carol does now have 10 tokens on this chain and she authenticated the "
"transfer indirectly by signing her block. The crowd-funding application now "
"makes a note in its application state on Bob's chain that Carol has pledged "
"10 Pugecoin tokens."
msgstr ""

#: src/sdk/composition.md:66
msgid ""
"For the complete code please take a look at the `crowd-funding` and "
"`fungible` applications in the `examples` folder in `linera-protocol`."
msgstr ""

#: src/sdk/logging.md:1
msgid "3.9. Printing Logs from an Application"
msgstr ""

#: src/sdk/logging.md:3
msgid ""
"Applications can use the [`log` crate](https://crates.io/crates/log) to "
"print log messages with different levels of importance. Log messages are "
"useful during development, but they may also be useful for end users. By "
"default the `linera service` command will log the messages from an "
"application if they are of the \"info\" importance level or higher (briefly, "
"`log::info!`, `log::warn!` and `log::error!`)."
msgstr ""

#: src/sdk/logging.md:5
msgid ""
"During development it is often useful to log messages of lower importance "
"(such as `log::debug!` and `log::trace!`). To enable them, the `RUST_LOG` "
"environment variable must be set before running `linera service`. The "
"example below enables trace level messages from applications and enables "
"warning level messages from other parts of the `linera` binary:"
msgstr ""

#: src/sdk/logging.md:7
msgid ""
"```ignore\n"
"export RUST_LOG=\"warn,linera_execution::wasm=trace\"\n"
"```"
msgstr ""

#: src/sdk/testing.md:1
msgid "3.10. Writing Tests"
msgstr ""

#: src/sdk/testing.md:3
msgid ""
"Linera applications can be tested using unit tests or integration tests. "
"Both are a bit different than usual Rust tests. Unit tests are executed "
"inside a WebAssembly virtual machine in an environment that simulates a "
"single microchain and a single application. System APIs are only available "
"if they are mocked using helper functions from `linera_sdk::test`."
msgstr ""

#: src/sdk/testing.md:5
msgid ""
"Integration tests run outside a WebAssembly virtual machine, and use a "
"simulated validator for testing. This allows creating chains and adding "
"blocks to them in order to test interactions between multiple microchains "
"and multiple applications."
msgstr ""

#: src/sdk/testing.md:7
msgid ""
"Applications should consider having both types of tests. Unit tests should "
"be used to focus on the application's internals and core functionality. "
"Integration tests should be used to test how the application behaves on a "
"more complex environment that's closer to the real network."
msgstr ""

#: src/sdk/testing.md:9
msgid ""
"In most cases, the simplest way to run both unit tests and integration tests "
"is to call `linera project test` from the project's directory."
msgstr ""

#: src/sdk/testing.md:11
msgid "[Unit tests](https://linera.dev/sdk/testing.html#unit-tests)"
msgstr ""

#: src/sdk/testing.md:13
msgid ""
"Unit tests are written beside the application's source code (i.e., inside "
"the `src` directory of the project). There are several differences to normal "
"Rust unit tests:"
msgstr ""

#: src/sdk/testing.md:15
msgid "the target `wasm32-unknown-unknown` must be selected;"
msgstr ""

#: src/sdk/testing.md:16
msgid "the custom test runner `linera-wasm-test-runner` must be used;"
msgstr ""

#: src/sdk/testing.md:17
msgid ""
"the [`#[webassembly_test\\]`](https://docs.rs/webassembly-test/latest/"
"webassembly_test/) attribute must be used instead of the usual `#[test]` "
"attribute."
msgstr ""

#: src/sdk/testing.md:19
msgid "The first two items are done automatically by `linera project test`."
msgstr ""

#: src/sdk/testing.md:21
msgid ""
"Alternatively, one may set up the environment and run `cargo test` directly "
"as described [below](https://linera.dev/sdk/testing.html#manually-"
"configuring-the-environment)."
msgstr ""

#: src/sdk/testing.md:23
msgid "[Example](https://linera.dev/sdk/testing.html#example)"
msgstr ""

#: src/sdk/testing.md:25
msgid ""
"A simple unit test is shown below, which tests if the application's "
"`do_something` method changes the application state."
msgstr ""

#: src/sdk/testing.md:36
msgid "// Configure the application's initial state\n"
msgstr ""

#: src/sdk/testing.md:44
msgid "// Define the application's expected final state\n"
msgstr ""

#: src/sdk/testing.md:51
msgid ""
"[Mocking System APIs](https://linera.dev/sdk/testing.html#mocking-system-"
"apis)"
msgstr ""

#: src/sdk/testing.md:53
msgid ""
"Unit tests run in a constrained environment, so things like access to the "
"key-value store, cross-chain messages and cross-application calls can't be "
"executed. However, they can be simulated using mock APIs. The `linera-sdk::"
"test` module provides some helper functions to mock the system APIs."
msgstr ""

#: src/sdk/testing.md:55
msgid "Here's an example mocking the key-value store."
msgstr ""

#: src/sdk/testing.md:68
msgid "// Assuming the application uses views\n"
msgstr ""

#: src/sdk/testing.md:71
msgid "\"Mock key-value store returns immediately\""
msgstr ""

#: src/sdk/testing.md:72
msgid "\"Failed to load view from mock key-value store\""
msgstr ""

#: src/sdk/testing.md:74
msgid "// Assuming `do_something` changes the view, but does not persist it\n"
msgstr ""

#: src/sdk/testing.md:79
msgid ""
"// Check that the state in memory is different from the state in storage\n"
msgstr ""

#: src/sdk/testing.md:85
msgid ""
"[Running Unit Tests with `cargo test`](https://linera.dev/sdk/testing."
"html#running-unit-tests-with-cargo-test)"
msgstr ""

#: src/sdk/testing.md:87
msgid ""
"Running `linera project test` is easier, but if there's a need to run `cargo "
"test` explicitly to run the unit tests, Cargo must be configured to use the "
"custom test runner `linera-wasm-test-runner`. This binary can be built from "
"the repository or installed with `cargo install linera-sdk`."
msgstr ""

#: src/sdk/testing.md:94
msgid ""
"The steps above build the `linera-wasm-test-runner` and places the resulting "
"binary at `linera-protocol/target/release/linera-wasm-test-runner`."
msgstr ""

#: src/sdk/testing.md:96
msgid ""
"With the binary available, the last step is to configure Cargo. There are a "
"few ways to do this. A quick way is to set the "
"`CARGO_TARGET_WASM32_UNKNOWN_UNKNOWN_RUNNER` environment variable to the "
"path of the binary."
msgstr ""

#: src/sdk/testing.md:98
msgid ""
"A more persistent way is to change one of [Cargo's configuration files]"
"(https://doc.rust-lang.org/cargo/reference/config.html#hierarchical-"
"structure). As an example, the following file can be placed inside the "
"project's directory at `PROJECT_DIR/.cargo/config.toml`:"
msgstr ""

#: src/sdk/testing.md:100
msgid ""
"```ignore\n"
"[target.wasm32-unknown-unknown]\n"
"runner = \"PATH_TO/linera-wasm-test-runner\"\n"
"```"
msgstr ""

#: src/sdk/testing.md:105
msgid "After configuring the test runner, unit tests can be executed with"
msgstr ""

#: src/sdk/testing.md:111
msgid ""
"Optionally, `wasm32-unknown-unknown` can be made the default build target "
"with the following lines in `PROJECT_DIR/.cargo/config.toml`:"
msgstr ""

#: src/sdk/testing.md:113
msgid ""
"```ignore\n"
"[build]\n"
"target = \"wasm32-unknown-unknown\"\n"
"```"
msgstr ""

#: src/sdk/testing.md:118
msgid ""
"[Integration Tests](https://linera.dev/sdk/testing.html#integration-tests)"
msgstr ""

#: src/sdk/testing.md:120
msgid ""
"Integration tests are usually written separately from the application's "
"source code (i.e., inside a `tests` directory that's beside the `src` "
"directory)."
msgstr ""

#: src/sdk/testing.md:122
msgid ""
"Integration tests are normal Rust integration tests, and they are compiled "
"to the **host** target instead of the `wasm32-unknown-unknown` target used "
"for unit tests. This is because unit tests run inside a WebAssembly virtual "
"machine and integration tests run outside a virtual machine, starting "
"isolated virtual machines to run each operation of each block added to each "
"chain."
msgstr ""

#: src/sdk/testing.md:124
msgid ""
"Integration tests can be run with `linera project test` or simply `cargo "
"test`."
msgstr ""

#: src/sdk/testing.md:126
msgid ""
"If you wish to use `cargo test` and have overridden your default target to "
"be in `wasm32-unknown-unknown` in `.cargo/config.toml`, you will have to "
"pass a native target to `cargo`, for instance `cargo test --target aarch64-"
"apple-darwin`."
msgstr ""

#: src/sdk/testing.md:128
msgid ""
"Integration tests use the helper types from `linera_sdk::test` to set up a "
"simulated Linera network, and publish blocks to microchains in order to "
"execute the application."
msgstr ""

#: src/sdk/testing.md:130
msgid "[Example](https://linera.dev/sdk/testing.html#example-1)"
msgstr ""

#: src/sdk/testing.md:132
msgid ""
"A simple test that sends a message between application instances on "
"different chains is shown below."
msgstr ""

#: src/advanced_topics.md:3
msgid ""
"In this section, we present additional topics related to the Linera protocol."
msgstr ""

#: src/advanced_topics/views.md:1
msgid "4.1. Views"
msgstr ""

#: src/advanced_topics/views.md:3
msgid ""
"Views are a specific functionality of the Linera system that allow to have "
"data in memory and then seamlessly flush it to an underlying persistent "
"datastore."
msgstr ""

#: src/advanced_topics/views.md:5
msgid ""
"The [full documentation](https://docs.rs/linera-views/latest/linera_views/) "
"is available on the crate documentation with all functions having examples."
msgstr ""

#: src/advanced_topics/views.md:7
msgid "Concretely, what is provided is the following:"
msgstr ""

#: src/advanced_topics/views.md:9
msgid ""
"A trait `View` that provides `load`, `rollback`, `clear`, `flush`, `delete`. "
"The idea is that we can do operation on the data and then flush it to the "
"database storing them."
msgstr ""

#: src/advanced_topics/views.md:10
msgid ""
"Several other traits `HashableView`, `RootView`, `CryptoHashView`, "
"`CryptoHashRootView` that are important for computing hash."
msgstr ""

#: src/advanced_topics/views.md:11
msgid ""
"A number of standard containers: `MapView`, `SetView`, `LogView`, "
"`QueueView`, `RegisterView` that implement the `View` and `HashableView` "
"traits."
msgstr ""

#: src/advanced_topics/views.md:12
msgid ""
"Two containers `CollectionView` and `ReentrantCollectionView` that are "
"similar to `MapView` but whose values are views themselves."
msgstr ""

#: src/advanced_topics/views.md:13
msgid ""
"Derive macros that allow to implement the above mentioned traits on struct "
"data types whose entries are views."
msgstr ""

#: src/advanced_topics/persistent_storage.md:1
msgid "4.2. Persistent Storage"
msgstr ""

#: src/advanced_topics/persistent_storage.md:3
msgid ""
"Validators run the servers and the data is stored in persistent storage. As "
"a consequence we need a tool for working with persistent storage and so we "
"have added `linera-db` for that purpose."
msgstr ""

#: src/advanced_topics/persistent_storage.md:5
msgid ""
"[Available persistent storage](https://linera.dev/advanced_topics/"
"persistent_storage.html#available-persistent-storage)"
msgstr ""

#: src/advanced_topics/persistent_storage.md:7
msgid ""
"The persistent storage that are available right now are `RocksDB`, "
"`DynamoDB` and `ScyllaDB`. Each has its own strengths and weaknesses."
msgstr ""

#: src/advanced_topics/persistent_storage.md:9
msgid ""
"[`RocksDB`](https://rocksdb.org/): Data is stored on disk and cannot be "
"shared between shards but is very fast."
msgstr ""

#: src/advanced_topics/persistent_storage.md:10
msgid ""
"[`DynamoDB`](https://aws.amazon.com/dynamodb/): Data is stored on a remote "
"storage, that has to be on AWS. Data can be shared between shards."
msgstr ""

#: src/advanced_topics/persistent_storage.md:11
msgid ""
"[`ScyllaDB`](https://www.scylladb.com/): Data is stored on a remote storage. "
"Data can be shared between shards."
msgstr ""

#: src/advanced_topics/persistent_storage.md:13
msgid ""
"There is no fundamental obstacle to the addition of other persistent storage "
"solutions."
msgstr ""

#: src/advanced_topics/persistent_storage.md:15
msgid ""
"In addition, the `DynamoDB` and `ScyllaDB` have the notion of a table which "
"means that a given remote location can be used for several completely "
"independent purposes."
msgstr ""

#: src/advanced_topics/persistent_storage.md:17
msgid ""
"[The `linera-db` tool](https://linera.dev/advanced_topics/persistent_storage."
"html#the-linera-db-tool)"
msgstr ""

#: src/advanced_topics/persistent_storage.md:19
msgid ""
"When operating on a persistent storage some global operations can be "
"required. The command line tool `linera-db` helps in making them work."
msgstr ""

#: src/advanced_topics/persistent_storage.md:21
msgid "The functionalities are the following:"
msgstr ""

#: src/advanced_topics/persistent_storage.md:23
msgid ""
"`list_tables`(`DynamoDB` and `ScyllaDB`): It lists all the tables that have "
"been created on the persistent storage"
msgstr ""

#: src/advanced_topics/persistent_storage.md:24
msgid ""
"`initialize`(`RocksDB`, `DynamoDB` and `ScyllaDB`): It initializes a "
"persistent storage."
msgstr ""

#: src/advanced_topics/persistent_storage.md:25
msgid ""
"`check_existence`(`RocksDB`, `DynamoDB` and `ScyllaDB`): It tests the "
"existence of a persistent storage. If the error code is 0 then the table "
"exists, if the error code is 1 then the table is absent."
msgstr ""

#: src/advanced_topics/persistent_storage.md:26
msgid ""
"`check_absence`(`RocksDB`, `DynamoDB` and `ScyllaDB`): It tests the absence "
"of a persistent storage. If the error code is 0 then the table is absent, if "
"the error code is 1 then the table does not exist."
msgstr ""

#: src/advanced_topics/persistent_storage.md:27
msgid ""
"`delete_all`(`RocksDB`, `DynamoDB` and `ScyllaDB`): It deletes all the table "
"of a persistent storage."
msgstr ""

#: src/advanced_topics/persistent_storage.md:28
msgid ""
"`delete_single`(`DynamoDB` and `ScyllaDB`): It deletes a single table of a "
"persistent storage."
msgstr ""

#: src/advanced_topics/persistent_storage.md:30
msgid ""
"If some error occurs during the operation, then the error code 2 is returned "
"and 0 if everything went fine with the exception of `check_existence` and "
"`check_absence` for which the value 1 can occur if the connection with the "
"database was established correctly but the result is not what we expected."
msgstr ""

#: src/advanced_topics/validators.md:1
msgid "4.3. Validators"
msgstr ""

#: src/advanced_topics/validators.md:3
msgid ""
"Validators run the servers that allow users to download and create blocks. "
"They validate, execute and cryptographically certify the blocks of all the "
"chains."
msgstr ""

#: src/advanced_topics/validators.md:5
msgid ""
"In Linera, every chain is backed by the same set of validators and has the "
"same level of security."
msgstr ""

#: src/advanced_topics/validators.md:7
msgid ""
"The main function of validators is to guarantee the integrity of the "
"infrastructure in the sense that:"
msgstr ""

#: src/advanced_topics/validators.md:9
msgid ""
"Each block is valid, i.e. it has the correct format, its operations are "
"allowed, the received messages are in the correct order, and e.g. the "
"balance was correctly computed."
msgstr ""

#: src/advanced_topics/validators.md:10
msgid "Every message received by one chain was actually sent by another chain."
msgstr ""

#: src/advanced_topics/validators.md:11
msgid ""
"If one block on a particular height is certified, no other block on the same "
"height is."
msgstr ""

#: src/advanced_topics/validators.md:13
msgid ""
"These properties are guaranteed to hold as long as two third of the "
"validators (weighted by their stake) follow the protocol. In the future, "
"deviating from the protocol may cause a validator to be considered malicious "
"and to lose their _stake_."
msgstr ""

#: src/advanced_topics/validators.md:15
msgid ""
"Validators also play a role in the liveness of the system by making sure "
"that the history of the chains stays available. However, since validators do "
"not propose blocks on most chains (see [next section](https://linera.dev/"
"advanced_topics/block_creation.html)), they do _not_ guarantee that any "
"particular operation or message will eventually be executed on a chain. "
"Instead, chain owners decide whether and when to propose new blocks, and "
"which operations and messages to include. The current implementation of the "
"Linera client automatically includes all incoming messages in new blocks. "
"The operations are the actions the chain owner explicitly adds, e.g. "
"transfer."
msgstr ""

#: src/advanced_topics/validators.md:17
msgid ""
"[Architecture of a validator](https://linera.dev/advanced_topics/validators."
"html#architecture-of-a-validator)"
msgstr ""

#: src/advanced_topics/validators.md:19
msgid ""
"Since every chain uses the same validators, adding more chains does not "
"require adding validators. Instead, it requires each individual validator to "
"scale out by adding more computation units, also known as \"workers\" or "
"\"physical shards\"."
msgstr ""

#: src/advanced_topics/validators.md:21
msgid "In the end, a Linera validator resembles a Web2 service made of"
msgstr ""

#: src/advanced_topics/validators.md:23
msgid ""
"a load balancer (aka. ingress/egress), currently implemented by the binary "
"`linera-proxy`,"
msgstr ""

#: src/advanced_topics/validators.md:24
msgid ""
"a number of workers, currently implemented by the binary `linera-server`,"
msgstr ""

#: src/advanced_topics/validators.md:25
msgid ""
"a shared database, currently implemented by the abstract interface `linera-"
"storage`."
msgstr ""

#: src/advanced_topics/validators.md:53
msgid ""
"Inside a validator, components communicate using the internal network of the "
"validator. Notably, workers use direct Remote Procedure Calls (RPCs) with "
"each other to deliver cross-chain messages."
msgstr ""

#: src/advanced_topics/validators.md:55
msgid ""
"Note that the number of workers may vary for each validator. Both the load "
"balancer and the shared database are represented as a single entity but are "
"meant to scale out in production."
msgstr ""

#: src/advanced_topics/validators.md:57
msgid ""
"For local testing during development, we currently use a single worker and "
"RocksDB as a database."
msgstr ""

#: src/advanced_topics/block_creation.md:1
msgid "4.4. Creating New Blocks"
msgstr ""

#: src/advanced_topics/block_creation.md:3
msgid ""
"In Linera, the responsibility of proposing blocks is separate from the task "
"of validating blocks."
msgstr ""

#: src/advanced_topics/block_creation.md:5
msgid ""
"While all chains are validated in the same way, the Linera protocol defines "
"several types of chains, depending on how new blocks are produced."
msgstr ""

#: src/advanced_topics/block_creation.md:7
msgid ""
"The simplest and lowest-latency type of chain is called _single-owner_ chain."
msgstr ""

#: src/advanced_topics/block_creation.md:8
msgid ""
"Other types of Linera chains not currently supported in the SDK include "
"_permissioned chains_ and _public chains_ (see the [whitepaper](https://"
"linera.io/whitepaper) for more context)."
msgstr ""

#: src/advanced_topics/block_creation.md:10
msgid ""
"For most types of chains (all but _public chains_), Linera validators do not "
"need to exchange messages with each other."
msgstr ""

#: src/advanced_topics/block_creation.md:12
msgid ""
"Instead, the wallets (aka. `linera` clients) of chain owners make the system "
"progress by proposing blocks and actively providing any additional required "
"data to the validators. For instance, client commands such as `transfer`, "
"`publish-bytecode`, or `open-chain` perform multiple steps to append a block "
"containing the token transfer, application publishing, or chain creation "
"operation:"
msgstr ""

#: src/advanced_topics/block_creation.md:14
msgid ""
"The Linera client creates a new block containing the desired operation and "
"new incoming messages, if there are any. It also contains the most recent "
"block's hash to designate its parent. The client sends the new block to all "
"validators."
msgstr ""

#: src/advanced_topics/block_creation.md:15
msgid ""
"The validators validate the block, i.e. check that the block satisfies the "
"conditions listed above, and send a cryptographic signature to the client, "
"indicating that they vote to append the new block. But only if they have not "
"voted for a different block on the same height earlier!"
msgstr ""

#: src/advanced_topics/block_creation.md:16
msgid ""
"The client ideally receives a vote from every validator, but only a quorum "
"of votes (say, two thirds) are required: These constitute a \"certificate\", "
"proving that the block was confirmed. The client sends the certificate to "
"every validator."
msgstr ""

#: src/advanced_topics/block_creation.md:17
msgid ""
"The validators \"execute\" the block: They update their own view of the most "
"recent state of the chain by applying all messages and operations, and if it "
"generated any cross-chain messages, they send these to the appropriate "
"workers."
msgstr ""

#: src/advanced_topics/block_creation.md:19
msgid ""
"To guarantee that each incoming message in a block was actually sent by "
"another chain, a validator will, in the second step, only _vote_ for a block "
"if it has already executed the block that sent it. However, when receiving a "
"valid certificate for a block that receives a message it has not seen yet, "
"it will accept and _execute_ the block anyway. The certificate is proof that "
"most other validators have seen the message, so it must be correct."
msgstr ""

#: src/advanced_topics/block_creation.md:21
msgid ""
"In the case of single-owner chains, clients must be carefully implemented so "
"that they never propose multiple blocks at the same height. Otherwise, the "
"chain may be stuck: once each of the two conflicting blocks has been signed "
"by enough validators, it becomes impossible to collect a quorum of votes for "
"either block."
msgstr ""

#: src/advanced_topics/block_creation.md:23
msgid ""
"In the future, we anticipate that most users will use _permissioned chains_ "
"even if they are the only owners of their chains. Permissioned chains have "
"two confirmation steps instead of one, but it is not possible to "
"accidentally make a chain unextendable. They also allow users to delegate "
"certain admistrative tasks to third-parties, notably to help with epoch "
"changes (i.e. when the validators change if reconfigured)."
msgstr ""

#: src/appendix/glossary.md:1
msgid "5.1. Glossary"
msgstr ""

#: src/appendix/glossary.md:3
msgid ""
"**Address**: A unique public alphanumeric identifier used to designate the "
"identity of an entity on the Linera network."
msgstr ""

#: src/appendix/glossary.md:4
msgid ""
"**Admin Chain**: The Linera Network has one designated _admin chain_ where "
"validators can join or leave and where new epochs are defined."
msgstr ""

#: src/appendix/glossary.md:5
msgid ""
"**Application**: Similar to a smart-contract on Ethereum, an application is "
"code deployed on the Linera network which is executed by all validators. An "
"application has a metered _contract_ which executes 'business logic' and "
"modifies state and an unmetered 'service' which is a read-only view into an "
"application's state."
msgstr ""

#: src/appendix/glossary.md:6
msgid ""
"**Byzantine Fault-Tolerant (BFT)**: A system which can operate correctly and "
"achieve consensus even if components of the system fail or act maliciously."
msgstr ""

#: src/appendix/glossary.md:7
msgid ""
"**Block Height**: The number of blocks preceding a given block on a specific "
"microchain."
msgstr ""

#: src/appendix/glossary.md:8
msgid ""
"**Block Proposal**: A candidate block proposed by a chain owner which may be "
"selected at the next block height."
msgstr ""

#: src/appendix/glossary.md:9
msgid ""
"**Bytecode**: A collection of bytes corresponding to a program that can be "
"run by the Wasm virtual machine."
msgstr ""

#: src/appendix/glossary.md:10
msgid ""
"**Client**: The `linera` program, which is a local node and wallet operated "
"by users to make requests to the network. In Linera, clients drive the "
"network by proposing new blocks and validators are mostly reactive."
msgstr ""

#: src/appendix/glossary.md:11
msgid ""
"**Certificate**: A value with signatures from a quorum of validators. Values "
"can be confirmed blocks, meaning that the block has been added to the chain "
"and is final. There are other values that are used for reaching consensus, "
"before certifying a confirmed block."
msgstr ""

#: src/appendix/glossary.md:12
msgid ""
"**Committee**: The set of all validators for a particular _epoch_, together "
"with their voting weights."
msgstr ""

#: src/appendix/glossary.md:13
msgid ""
"**Chain Owner**: The owner of a _user chain_ or _permissioned chain_. This "
"is represented as the alphanumeric identifier derived from the hash of the "
"owner's public key."
msgstr ""

#: src/appendix/glossary.md:14
msgid ""
"**Channel**: A broadcast mechanism enabling publish-subscribe behavior "
"across chains."
msgstr ""

#: src/appendix/glossary.md:15
msgid ""
"**Contract**: The metered part of an application which executes business "
"logic and can modify the application's state."
msgstr ""

#: src/appendix/glossary.md:16
msgid ""
"**Cross-Application Call**: A call from one application to another on the "
"_same chain_."
msgstr ""

#: src/appendix/glossary.md:17
msgid ""
"**Cross-Chain Message**: A message containing a data payload which is sent "
"from one chain to another. Cross-Chain messages are the asynchronous "
"communication primitive which enable communication on the same application "
"running on different chains."
msgstr ""

#: src/appendix/glossary.md:18
msgid ""
"**Epoch**: A period of time when a particular set of validators with "
"particular voting weights can certify new blocks. Since each chain has to "
"transition explicitly from one epoch to the next, epochs can overlap."
msgstr ""

#: src/appendix/glossary.md:19
msgid ""
"**Genesis Configuration**: The configuration determining the state of a "
"newly created network; the voting weights of the initial set of validators, "
"the initial fee structure, and initial chains that the network starts with."
msgstr ""

#: src/appendix/glossary.md:20
msgid ""
"**Inbox**: A commutative data structure storing incoming messages for a "
"given chain."
msgstr ""

#: src/appendix/glossary.md:21
msgid "**Message**: See 'Cross-Chain Message'."
msgstr ""

#: src/appendix/glossary.md:22
msgid ""
"**Microchain**: A lightweight chain of blocks holding a subset of the "
"network's state running on every validator. This is used interchangeably "
"with 'chain'. _All_ Linera chains are microchains."
msgstr ""

#: src/appendix/glossary.md:23
msgid ""
"**Network**: The totality of all protocol participants. A network is the "
"combination of committee, clients and auditors."
msgstr ""

#: src/appendix/glossary.md:24
msgid ""
"**Operation**: Operations are transactions directly added to a block by the "
"creator (and signer) of the block. Users typically use operations to start "
"interacting with an application on their own chain."
msgstr ""

#: src/appendix/glossary.md:25
msgid ""
"**Permissioned Chain**: A microchain which is owned by more than one user. "
"Users take turns proposing blocks and the likelihood of selection is "
"proportional to their _weight_."
msgstr ""

#: src/appendix/glossary.md:26
msgid ""
"**Project**: The collection of files and dependencies which are built into "
"the bytecode which is instantiated as an application on the Linera Network."
msgstr ""

#: src/appendix/glossary.md:27
msgid ""
"**Public Chain**: A microchain with full BFT consensus with a strict set of "
"permissions relied on for the operation of the network,"
msgstr ""

#: src/appendix/glossary.md:28
msgid ""
"**Quorum**: A set of validators representing > ⅔ of the total stake. A "
"quorum is required to create a certificate."
msgstr ""

#: src/appendix/glossary.md:29
msgid "**Single-Owner Chain**: See 'User Chain'."
msgstr ""

#: src/appendix/glossary.md:30
msgid "**Service**: An unmetered read-only view into an application's state."
msgstr ""

#: src/appendix/glossary.md:31
msgid ""
"**Shard**: A logical subset of all microchains on a given validator. This "
"corresponds directly to a physical _worker_."
msgstr ""

#: src/appendix/glossary.md:32
msgid ""
"**Stake**: An amount of tokens pledged by a validator or auditor, as a "
"collateral to guarantee their honest and correct participation in the "
"network."
msgstr ""

#: src/appendix/glossary.md:33
msgid ""
"**User Chain**: Used interchangeably with _Single-Owner Chain_. User chains "
"are chains which are owned by a single user on the network. Only the chain "
"owner can propose blocks, and therefore only the chain owner can forcibly "
"advance the state of a user chain."
msgstr ""

#: src/appendix/glossary.md:34
msgid ""
"**Validator**: Validators run the servers that allow users to download and "
"create blocks. They validate, execute and cryptographically certify the "
"blocks of all the chains."
msgstr ""

#: src/appendix/glossary.md:35
msgid ""
"**View**: Views are like an Object-Relational Mapping (ORM) for mapping "
"complex types onto key-value stores. Views group complex state changes into "
"a set of elementary operations and commit them atomically. They are full or "
"partial in-memory representations of complex types saved on disk in a key-"
"value store"
msgstr ""

#: src/appendix/glossary.md:36
msgid ""
"**Wallet**: A file containing a user's public and private keys along with "
"configuration and information regarding the chains they own."
msgstr ""

#: src/appendix/glossary.md:37
msgid ""
"**WebAssembly (Wasm)**: A binary compilation target and instruction format "
"that runs on a stack-based VM. Linera applications are compiled to Wasm and "
"run on Wasm VMs inside validators and clients."
msgstr ""

#: src/appendix/glossary.md:38
msgid ""
"**Web3**: A natural evolution of the internet focusing on decentralization "
"by leveraging blockchains and smart contracts."
msgstr ""

#: src/appendix/glossary.md:39
msgid ""
"**Worker**: A process which runs a subset of all microchains on a given "
"validator. This corresponds directly to a logical _shard_."
msgstr ""

#: src/videos.md:3
msgid ""
"We're consistently improving the SDK and creating new material. We recorded "
"the following tutorial videos for the Linera Developer Summer School 2023:"
msgstr ""

#: src/videos.md:5
msgid ""
"[Build and deploy your first applications](https://www.youtube.com/watch?"
"v=Zr6BWodQ0sI)"
msgstr ""

#: src/videos.md:6
msgid ""
"[Add testing, logging, and more to your app](https://www.youtube.com/watch?"
"v=Aq9jCeEl02k)"
msgstr ""

#: src/videos.md:7
msgid ""
"[Use cross-application calls to call other apps](https://www.youtube.com/"
"watch?v=5M5Ju35AnPE)"
msgstr ""

#: src/videos.md:9
msgid "_Happy viewing!_"
msgstr ""
